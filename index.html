<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Pilot: All Assets Loaded</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 480px; background: #000; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI å±¤ */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; z-index: 10; }
        .hud-text { padding: 15px; font-weight: bold; text-shadow: 2px 2px #000; font-size: 18px; }
        
        /* æ ¸å½ˆæŒ‰éˆ• - ç›´æ¥ä½¿ç”¨ CSS è®€å–åœ–ç‰‡ */
        #nuke-container { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; pointer-events: auto; }
        .nuke-btn { 
            width: 50px; height: 50px; 
            /* é€™è£¡ç›´æ¥å°æ‡‰ä½ çš„ rocket_icon.png */
            background: rgba(0,0,0,0.3) url('rocket_icon.png') center/cover no-repeat;
            border-radius: 50%; border: 2px solid #fff; cursor: pointer; 
            box-shadow: 0 0 10px #f00; 
        }
        .nuke-btn:active { transform: scale(0.9); filter: brightness(1.5); }

        /* Boss è¡€æ¢ */
        #boss-hp-bar { display: none; position: absolute; top: 80px; left: 10%; width: 80%; height: 20px; background: #222; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #boss-hp-inner { width: 100%; height: 100%; background: linear-gradient(90deg, #f00, #ff8800); transition: width 0.2s; }

        /* ç‰¹æ•ˆå±¤ (GIF) */
        #vfx-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; mix-blend-mode: screen; pointer-events: none; z-index: 5; }
        #vfx-layer img { width: 100%; height: 100%; object-fit: cover; }
        
        /* ç™½å…‰é–ƒçˆ */
        #flash-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 20; transition: opacity 0.1s; }
        
        #msg-center { position: absolute; top: 40%; width: 100%; text-align: center; font-size: 40px; color: #ff0; font-weight: bold; text-shadow: 0 0 20px red; display: none; }
        
        /* è®€å–ç‹€æ…‹ */
        #debug { position: absolute; bottom: 10px; left: 10px; color: #888; font-size: 12px; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="vfx-layer"><img id="nuke-gif" src="" alt=""></div>
        <div id="flash-layer"></div>

        <div id="ui">
            <div class="hud-text">
                <span style="color:#0ff">TIME: <span id="timer">120</span>s</span><br>
                <span id="shield-txt" style="color:#0f0; display:none;">ğŸ›¡ï¸ SHIELD ACTIVE</span>
            </div>
            <div id="nuke-container"></div>
            <div id="boss-hp-bar"><div id="boss-hp-inner"></div></div>
            <div id="msg-center">WARNING!</div>
            <div id="debug">Loading assets...</div>
        </div>
    </div>

<script>
// === 1. ç³»çµ±åˆå§‹åŒ– ===
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    timer: document.getElementById('timer'),
    shieldTxt: document.getElementById('shield-txt'),
    nukeBox: document.getElementById('nuke-container'),
    bossBar: document.getElementById('boss-hp-bar'),
    bossFill: document.getElementById('boss-hp-inner'),
    msg: document.getElementById('msg-center'),
    vfx: document.getElementById('vfx-layer'),
    nukeGif: document.getElementById('nuke-gif'),
    flash: document.getElementById('flash-layer'),
    debug: document.getElementById('debug')
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// === 2. åœ–ç‰‡è³‡æºè¼‰å…¥ (é—œéµï¼šå®Œå…¨å°æ‡‰ä½ çš„æª”å) ===
const assets = {};
// é€™è£¡çš„ key å°æ‡‰ç¨‹å¼ç¢¼é‚è¼¯ï¼Œvalue å°æ‡‰ä½ çš„å¯¦éš›æª”å
const imageSources = {
    player: 'player.png',
    bullet_player: 'bullet_player.png',
    
    enemy_minion: 'enemy_minion.png',
    enemy_turtle: 'enemy_turtle.png',
    enemy_bullet: 'enemy_bullet.png',
    
    boss: 'boss.png',
    
    item_shield: 'item_shield.png',
    item_power: 'item_power.png',
    
    bg: 'bg_space.png',
    vfx_shield: 'vfx_shield.png',
    
    // æ ¸å½ˆç›¸é—œ
    rocket_icon: 'rocket_icon.png',
    nuke_explosion: 'nuke_explosion.gif'
};

let loadedCount = 0;
const totalImages = Object.keys(imageSources).length;

// é è¼‰å…¥æ‰€æœ‰åœ–ç‰‡
for(let key in imageSources) {
    const img = new Image();
    img.src = imageSources[key];
    img.onload = () => {
        assets[key] = img;
        loadedCount++;
        ui.debug.innerText = `Assets loaded: ${loadedCount}/${totalImages}`;
        if(loadedCount === totalImages) ui.debug.innerText = ""; // è¼‰å…¥å®Œæˆéš±è—æ–‡å­—
    };
    img.onerror = () => {
        console.warn("Missing file: " + imageSources[key]);
        ui.debug.innerText = "Missing: " + imageSources[key];
    };
}

// === 3. æ‰‹æ©Ÿè§¸æ§è¼¸å…¥ (ä¿®æ­£ç‰ˆ) ===
const input = { x: canvas.width/2, y: canvas.height-100, pressing: false };

function handleInput(x, y, pressing) {
    input.x = x;
    input.y = y;
    input.pressing = pressing;
}

// è§¸æ§äº‹ä»¶ (åŠ ä¸Š passive: false é˜²æ­¢æ²å‹•)
canvas.addEventListener('touchstart', e => {
    e.preventDefault(); 
    handleInput(e.touches[0].clientX, e.touches[0].clientY, true);
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault(); 
    handleInput(e.touches[0].clientX, e.touches[0].clientY, true);
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    input.pressing = false;
});

// æ»‘é¼ äº‹ä»¶ (é›»è…¦æ¸¬è©¦ç”¨)
canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY, true));
canvas.addEventListener('mousemove', e => { if(input.pressing) handleInput(e.clientX, e.clientY, true); });
canvas.addEventListener('mouseup', () => input.pressing = false);


// === 4. éŠæˆ²é‚è¼¯ ===
const gameState = {
    player: { x: canvas.width/2, y: canvas.height-100, w: 64, h: 64 },
    bullets: [],
    enemies: [],
    enemyBullets: [],
    items: [],
    boss: null,
    nukes: 3,
    shake: 0,
    time: 120,
    powerLevel: 1, 
    shieldTime: 0,
    lastTime: 0
};

// æ ¸å½ˆ UI åˆå§‹åŒ–
function initNukeUI() {
    ui.nukeBox.innerHTML = '';
    for(let i=0; i<gameState.nukes; i++) {
        const btn = document.createElement('div');
        btn.className = 'nuke-btn'; // æœƒè‡ªå‹•åƒ CSS çš„èƒŒæ™¯åœ–
        
        // é»æ“Šè§¸ç™¼
        const trigger = (e) => { e.stopPropagation(); fireNuke(btn); };
        btn.addEventListener('touchstart', trigger);
        btn.addEventListener('mousedown', trigger);
        
        ui.nukeBox.appendChild(btn);
    }
}

function fireNuke(btn) {
    if(gameState.nukes <= 0) return;
    gameState.nukes--;
    btn.style.display = 'none';

    // éœ‡å‹• + é–ƒå…‰
    gameState.shake = 40;
    ui.flash.style.opacity = 1;
    setTimeout(() => ui.flash.style.opacity = 0, 150);

    // æ’­æ”¾ GIF
    ui.nukeGif.src = `nuke_explosion.gif?t=${Date.now()}`; // åŠ æ™‚é–“æˆ³å¼·åˆ¶é‡æ’­
    ui.vfx.style.display = 'block';
    setTimeout(() => ui.vfx.style.display = 'none', 1500); // 1.5ç§’å¾Œé—œé–‰

    // æ¸…å ´é‚è¼¯
    gameState.enemies = []; // ç§’æ®ºå°å…µ
    gameState.enemyBullets = [];
    if(gameState.boss) {
        gameState.boss.hp -= 300; // ç‚¸ Boss
        gameState.boss.y -= 50;   // æ“Šé€€ Boss
    }
}

function spawnBoss() {
    gameState.boss = {
        x: canvas.width/2, y: -150,
        w: 200, h: 150,
        hp: 1500, maxHp: 1500,
        dir: 1, shootTimer: 0
    };
    ui.bossBar.style.display = 'block';
    ui.msg.innerText = "BOSS COMING!";
    ui.msg.style.display = 'block';
    setTimeout(() => ui.msg.style.display = 'none', 2000);
}

// === 5. æ›´æ–°å¾ªç’° ===
let shootTimer = 0;

function update(dt) {
    // å€’æ•¸è¨ˆæ™‚
    if(gameState.time > 0) {
        gameState.time -= dt;
        ui.timer.innerText = Math.ceil(gameState.time);
        if(gameState.time <= 0 && !gameState.boss) spawnBoss();
    }

    // éœ‡å‹•æ¢å¾©
    if(gameState.shake > 0) gameState.shake *= 0.9;

    // ç©å®¶ç§»å‹•
    if(input.pressing) {
        gameState.player.x += (input.x - gameState.player.x) * 0.2;
        gameState.player.y += (input.y - gameState.player.y) * 0.2;
    }

    // è­·ç›¾æ™‚é–“
    if(gameState.shieldTime > 0) {
        gameState.shieldTime -= dt;
        ui.shieldTxt.style.display = 'block';
    } else {
        ui.shieldTxt.style.display = 'none';
    }

    // ç©å®¶å°„æ“Š
    shootTimer -= dt;
    if(shootTimer <= 0) {
        const p = gameState.player;
        if(gameState.powerLevel === 1) {
            gameState.bullets.push({x: p.x, y: p.y-30, vx:0, vy:-800});
        } else {
            // æ•£å½ˆæ¨¡å¼
            gameState.bullets.push({x: p.x, y: p.y-30, vx:0, vy:-800});
            gameState.bullets.push({x: p.x-10, y: p.y-20, vx:-200, vy:-700});
            gameState.bullets.push({x: p.x+10, y: p.y-20, vx:200, vy:-700});
        }
        shootTimer = 0.15;
    }

    // ç”Ÿæˆæ•µäºº
    if(!gameState.boss && Math.random() < 0.03) {
        const isTurtle = Math.random() > 0.7;
        gameState.enemies.push({
            x: Math.random() * (canvas.width - 50) + 25,
            y: -50,
            type: isTurtle ? 'turtle' : 'minion',
            w: isTurtle ? 64 : 48,
            h: isTurtle ? 64 : 48,
            hp: isTurtle ? 6 : 2,
            vy: isTurtle ? 80 : 250
        });
    }

    // æ›´æ–°å„ç‰©ä»¶ä½ç½®
    gameState.bullets.forEach(b => { b.x += b.vx*dt; b.y += b.vy*dt; });
    gameState.items.forEach(i => i.y += 150*dt);
    gameState.enemies.forEach(e => e.y += e.vy*dt);
    gameState.enemyBullets.forEach(b => { b.x += b.vx*dt; b.y += b.vy*dt; });

    // Boss é‚è¼¯
    if(gameState.boss) {
        const b = gameState.boss;
        if(b.y < 100) b.y += 50 * dt; // é€²å ´
        b.x += 100 * dt * b.dir;
        if(b.x > canvas.width - 100 || b.x < 100) b.dir *= -1;

        b.shootTimer -= dt;
        if(b.shootTimer <= 0) {
            // Boss ç™¼å°„å­å½ˆ
            gameState.enemyBullets.push({x: b.x, y: b.y+80, vx:0, vy:400});
            gameState.enemyBullets.push({x: b.x, y: b.y+80, vx:-150, vy:350});
            gameState.enemyBullets.push({x: b.x, y: b.y+80, vx:150, vy:350});
            b.shootTimer = 1.2;
        }
        ui.bossFill.style.width = (b.hp / b.maxHp * 100) + "%";
        if(b.hp <= 0) {
            gameState.boss = null;
            ui.bossBar.style.display = 'none';
            ui.msg.innerText = "BOSS DEFEATED!";
            ui.msg.style.display = 'block';
            gameState.shake = 50;
        }
    }

    // ç¢°æ’åµæ¸¬ï¼šå­å½ˆ vs æ•µäºº
    gameState.bullets = gameState.bullets.filter(b => {
        let hit = false;
        // æ‰“å°æ€ª
        for(let i=gameState.enemies.length-1; i>=0; i--) {
            let e = gameState.enemies[i];
            if(dist(b, e) < (e.w/2 + 10)) {
                e.hp--;
                hit = true;
                if(e.hp <= 0) {
                    if(Math.random() < 0.3) spawnItem(e.x, e.y);
                    gameState.enemies.splice(i, 1);
                }
                break;
            }
        }
        // æ‰“ Boss
        if(!hit && gameState.boss && dist(b, gameState.boss) < 80) {
            gameState.boss.hp -= 10; // ç©å®¶å­å½ˆå‚·å®³
            hit = true;
        }
        return !hit && b.y > -50;
    });

    // ç¢°æ’åµæ¸¬ï¼šç©å®¶åƒå¯¶ç‰©
    gameState.items = gameState.items.filter(item => {
        if(dist(gameState.player, item) < 40) {
            if(item.type === 'shield') gameState.shieldTime = 5;
            if(item.type === 'power') gameState.powerLevel = 2;
            return false;
        }
        return item.y < canvas.height;
    });

    // æ¸…ç†
    gameState.enemies = gameState.enemies.filter(e => e.y < canvas.height + 50);
}

function spawnItem(x, y) {
    gameState.items.push({
        x: x, y: y,
        type: Math.random() > 0.5 ? 'shield' : 'power'
    });
}

function dist(obj1, obj2) {
    return Math.hypot(obj1.x - obj2.x, obj1.y - obj2.y);
}

// === 6. ç•«é¢ç¹ªè£½ ===
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    // éœ‡å‹•æ•ˆæœ
    if(gameState.shake > 0.5) {
        ctx.translate((Math.random()-0.5)*gameState.shake, (Math.random()-0.5)*gameState.shake);
    }

    // 1. èƒŒæ™¯
    if(assets.bg && assets.bg.complete) ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);
    else { ctx.fillStyle = '#111'; ctx.fillRect(0,0,canvas.width, canvas.height); }

    // 2. å¯¶ç‰©
    gameState.items.forEach(i => {
        let img = (i.type === 'shield') ? assets.item_shield : assets.item_power;
        if(img && img.complete) ctx.drawImage(img, i.x-20, i.y-20, 40, 40);
        else { ctx.fillStyle = '#ff0'; ctx.fillRect(i.x-10, i.y-10, 20, 20); }
    });

    // 3. æ•µäºº
    gameState.enemies.forEach(e => {
        let img = (e.type === 'turtle') ? assets.enemy_turtle : assets.enemy_minion;
        if(img && img.complete) ctx.drawImage(img, e.x - e.w/2, e.y - e.h/2, e.w, e.h);
        else { ctx.fillStyle = '#f00'; ctx.fillRect(e.x-20, e.y-20, 40, 40); }
    });

    // 4. Boss
    if(gameState.boss) {
        let b = gameState.boss;
        if(assets.boss && assets.boss.complete) ctx.drawImage(assets.boss, b.x - b.w/2, b.y - b.h/2, b.w, b.h);
        else { ctx.fillStyle = '#a00'; ctx.fillRect(b.x-100, b.y-75, 200, 150); }
    }

    // 5. ç©å®¶
    let p = gameState.player;
    if(assets.player && assets.player.complete) ctx.drawImage(assets.player, p.x - p.w/2, p.y - p.h/2, p.w, p.h);
    else { ctx.fillStyle = '#00f'; ctx.fillRect(p.x-30, p.y-30, 60, 60); }

    // 6. è­·ç›¾ç‰¹æ•ˆ
    if(gameState.shieldTime > 0) {
        if(assets.vfx_shield && assets.vfx_shield.complete) {
            ctx.globalAlpha = 0.6;
            ctx.drawImage(assets.vfx_shield, p.x-48, p.y-48, 96, 96);
            ctx.globalAlpha = 1.0;
        } else {
            ctx.beginPath(); ctx.strokeStyle = '#0ff'; ctx.lineWidth=3; ctx.arc(p.x, p.y, 50, 0, Math.PI*2); ctx.stroke();
        }
    }

    // 7. å­å½ˆ
    gameState.bullets.forEach(b => {
        if(assets.bullet_player && assets.bullet_player.complete) ctx.drawImage(assets.bullet_player, b.x-8, b.y-16, 16, 32);
        else { ctx.fillStyle = '#0ff'; ctx.fillRect(b.x-2, b.y, 4, 10); }
    });

    // 8. æ•µæ–¹å­å½ˆ
    gameState.enemyBullets.forEach(b => {
        if(assets.enemy_bullet && assets.enemy_bullet.complete) ctx.drawImage(assets.enemy_bullet, b.x-10, b.y-10, 20, 20);
        else { ctx.fillStyle = '#f0f'; ctx.fillRect(b.x-3, b.y, 6, 6); }
    });

    ctx.restore();
}

function loop(timestamp) {
    if(!gameState.lastTime) gameState.lastTime = timestamp;
    const dt = (timestamp - gameState.lastTime) / 1000;
    gameState.lastTime = timestamp;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

// å•Ÿå‹•
initNukeUI();
requestAnimationFrame(loop);

</script>
</body>
</html>
