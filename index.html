<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Pilot: Final Polish</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Arial Black', sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 480px; background: #111; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI å±¤ */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; z-index: 10; }
        .hud-text { padding: 15px; font-weight: bold; text-shadow: 2px 2px #000; font-size: 18px; }
        
        /* æ ¸å½ˆæŒ‰éˆ• */
        #nuke-container { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; pointer-events: auto; }
        .nuke-btn { 
            width: 50px; height: 50px; 
            background-color: #444; 
            background-image: url('rocket_icon.png');
            background-position: center; background-size: cover; background-repeat: no-repeat;
            border-radius: 50%; border: 2px solid #fff; cursor: pointer; 
            box-shadow: 0 0 10px #f00; transition: transform 0.1s;
        }
        .nuke-btn:active { transform: scale(0.9); filter: brightness(1.5); }

        /* Boss è¡€æ¢ */
        #boss-hp-bar { display: none; position: absolute; top: 80px; left: 10%; width: 80%; height: 20px; background: #222; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #boss-hp-inner { width: 100%; height: 100%; background: linear-gradient(90deg, #f00, #ff8800); transition: width 0.2s; }

        /* ç‰¹æ•ˆå±¤ - å¼·åˆ¶å¡«æ»¿è¢å¹• */
        #vfx-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: none; pointer-events: none; z-index: 5;
            background: transparent; 
        }
        #vfx-layer img { 
            width: 100%; height: 100%; 
            object-fit: fill; /* æ”¹ç”¨ fill å¼·åˆ¶æ‹‰ä¼¸ï¼Œç¢ºä¿æ²’æœ‰é»‘é‚Š */
            mix-blend-mode: screen; 
        }
        #flash-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 20; transition: opacity 0.1s; }
        
        /* è¨Šæ¯èˆ‡å‹åˆ©ç•«é¢ */
        #msg-center { position: absolute; top: 40%; width: 100%; text-align: center; font-size: 40px; color: #ff0; font-weight: bold; text-shadow: 0 0 20px red; display: none; z-index: 30; }
        #victory-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); display: none; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 100; pointer-events: auto;
        }
        .champ-title { font-size: 50px; color: gold; text-shadow: 0 0 20px orange; margin-bottom: 20px; animation: glow 1s infinite alternate; }
        @keyframes glow { from { text-shadow: 0 0 10px gold; } to { text-shadow: 0 0 30px red; } }
        
        #restart-btn {
            background: #666; color: #fff; border: 2px solid #888; 
            padding: 10px 20px; font-size: 14px; cursor: pointer; border-radius: 5px;
            margin-top: 50px; font-family: sans-serif;
        }
        
        #debug { position: absolute; bottom: 10px; left: 10px; color: #ff5555; font-size: 12px; font-family: monospace; background: rgba(0,0,0,0.5); padding: 5px; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="vfx-layer"><img id="nuke-gif" src="" alt=""></div>
        <div id="flash-layer"></div>

        <div id="ui">
            <div class="hud-text">
                <span id="phase-txt" style="color:#0ff">INITIALIZING...</span><br>
                TIME: <span id="timer">100</span>s<br>
                <span id="shield-txt" style="color:#0f0; display:none;">ğŸ›¡ï¸ SHIELD ACTIVE</span>
            </div>
            <div id="nuke-container"></div>
            <div id="boss-hp-bar"><div id="boss-hp-inner"></div></div>
            <div id="msg-center"></div>
            <div id="debug">Loading...</div>
        </div>

        <div id="victory-screen">
            <div class="champ-title">ğŸ† CHAMPION</div>
            <div style="color:white; font-size:20px;">MISSION COMPLETE</div>
            <button id="restart-btn" onclick="restartGame()">å†ç©ä¸€å±€</button>
        </div>
    </div>

<script>
// === 1. åˆå§‹åŒ– ===
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    timer: document.getElementById('timer'),
    phase: document.getElementById('phase-txt'),
    shieldTxt: document.getElementById('shield-txt'),
    nukeBox: document.getElementById('nuke-container'),
    bossBar: document.getElementById('boss-hp-bar'),
    bossFill: document.getElementById('boss-hp-inner'),
    msg: document.getElementById('msg-center'),
    vfx: document.getElementById('vfx-layer'),
    nukeGif: document.getElementById('nuke-gif'),
    flash: document.getElementById('flash-layer'),
    victory: document.getElementById('victory-screen'),
    debug: document.getElementById('debug')
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// === 2. å®‰å…¨è³‡æºè¼‰å…¥ç³»çµ± ===
const assets = {};
const imageSources = {
    player: 'player.png',
    bullet_player: 'bullet_player.png',
    enemy_minion: 'enemy_minion.png',
    enemy_turtle: 'enemy_turtle.png',
    enemy_bullet: 'enemy_bullet.png',
    boss: 'boss.png',
    item_shield: 'item_shield.png',
    item_power: 'item_power.png',
    bg: 'bg_space.png',
    vfx_shield: 'vfx_shield.png',
    rocket_icon: 'rocket_icon.png',
    nuke_explosion: 'nuke_explosion.gif'
};

function createPlaceholder(color, text) {
    const c = document.createElement('canvas');
    c.width = 64; c.height = 64;
    const x = c.getContext('2d');
    x.fillStyle = color; x.fillRect(0,0,64,64);
    x.fillStyle = '#fff'; x.font = '10px Arial'; x.fillText(text || '?', 5, 35);
    x.strokeStyle = '#fff'; x.strokeRect(0,0,64,64);
    return c;
}

let loadedCount = 0;
const totalImages = Object.keys(imageSources).length;
let gameStarted = false;

for(let key in imageSources) {
    const img = new Image();
    img.src = imageSources[key];
    img.onload = () => { assets[key] = img; checkStart(); };
    img.onerror = () => {
        ui.debug.innerHTML += "<br>Missing: " + imageSources[key];
        assets[key] = createPlaceholder('#555', key);
        checkStart();
    };
}

function checkStart() {
    loadedCount++;
    if(loadedCount >= totalImages && !gameStarted) {
        ui.debug.innerText = "System Ready";
        startGame();
    }
}

// ä¿éšªï¼š3ç§’å¼·åˆ¶å•Ÿå‹•
setTimeout(() => {
    if(!gameStarted) {
        for(let key in imageSources) if(!assets[key]) assets[key] = createPlaceholder('#333', key);
        startGame();
    }
}, 3000);

// === 3. éŠæˆ²æ ¸å¿ƒè®Šæ•¸ ===
let gameState = {
    phase: 1, 
    totalTime: 100, 
    nukes: 3,
    shake: 0,
    gameOver: false,
    player: { x: canvas.width/2, y: canvas.height-100, w: 64, h: 64, stunTimer: 0 },
    bullets: [],
    enemies: [],
    enemyBullets: [],
    items: [],
    particles: [],
    boss: null,
    powerLevel: 1,
    shieldTime: 0,
    lastTime: 0
};

let shootTimer = 0;

function startGame() {
    if(gameStarted) return;
    gameStarted = true;

    // é‡ç½®åƒæ•¸
    gameState.phase = 1;
    gameState.totalTime = 100;
    gameState.nukes = 3;
    gameState.gameOver = false;
    gameState.player.stunTimer = 0;
    gameState.powerLevel = 1;
    gameState.shieldTime = 0;
    gameState.bullets = [];
    gameState.enemies = [];
    gameState.enemyBullets = [];
    gameState.items = [];
    gameState.boss = null;
    gameState.particles = [];
    
    ui.victory.style.display = 'none';
    ui.bossBar.style.display = 'none';
    ui.phase.innerText = "WAVE 1: MINIONS (40s)";
    ui.phase.style.color = "#0ff";
    
    updateNukeUI();
    requestAnimationFrame(loop);
}

// === 4. éŠæˆ²åŠŸèƒ½ ===
function updateNukeUI() {
    ui.nukeBox.innerHTML = '';
    for(let i=0; i<gameState.nukes; i++) {
        const btn = document.createElement('div');
        btn.className = 'nuke-btn';
        // ä¿®æ­£ï¼šæ ¸å½ˆæŒ‰éˆ•è¦èƒ½éš¨æ™‚é»æ“Šï¼ˆåªè¦é‚„æœ‰åº«å­˜ï¼‰
        const action = (e) => { e.stopPropagation(); fireNuke(); };
        btn.addEventListener('touchstart', action);
        btn.addEventListener('mousedown', action);
        ui.nukeBox.appendChild(btn);
    }
}

function fireNuke() {
    // ä¿®æ­£ï¼šç§»é™¤ stunTimer > 0 çš„é™åˆ¶ï¼Œè¢«æšˆçœ©æ™‚å¯ä»¥ç™¼å°„æ ¸å½ˆä¿å‘½ï¼
    if(gameState.nukes <= 0) return;
    
    gameState.nukes--;
    updateNukeUI();

    gameState.shake = 40;
    ui.flash.style.opacity = 1;
    setTimeout(() => ui.flash.style.opacity = 0, 150);

    // æ’­æ”¾ GIF (å¼·åˆ¶é‡åˆ·)
    ui.nukeGif.src = `nuke_explosion.gif?t=${Date.now()}`;
    ui.vfx.style.display = 'block';
    setTimeout(() => ui.vfx.style.display = 'none', 2500);

    // æ¸…å ´
    gameState.enemies.forEach(e => createExplosion(e.x, e.y, '#f00'));
    gameState.enemies = []; 
    gameState.enemyBullets = [];
    if(gameState.boss) {
        gameState.boss.hp -= 400;
        gameState.boss.y -= 50;
    }
}

// === 5. æ›´æ–°é‚è¼¯ ===
function update(dt) {
    if(gameState.gameOver) return;

    // æ™‚é–“
    if(gameState.totalTime > 0) {
        gameState.totalTime -= dt;
        ui.timer.innerText = Math.ceil(gameState.totalTime);

        // å‰© 60ç§’ é€² Boss
        if(gameState.totalTime <= 60 && gameState.phase === 1) {
            enterBossPhase();
        }
    } else {
        if(gameState.boss) {
            showMsg("TIME OVER", "#f00");
            gameState.gameOver = true;
            ui.phase.innerText = "GAME OVER";
        }
    }

    // ç©å®¶ç§»å‹•èˆ‡æšˆçœ©
    const p = gameState.player;
    if(p.stunTimer > 0) {
        p.stunTimer -= dt; // å€’æ•¸æšˆçœ©æ™‚é–“
    } else if(input.pressing) {
        p.x += (input.x - p.x) * 0.2;
        p.y += (input.y - p.y) * 0.2;
    }

    // ç©å®¶å°„æ“Š (æšˆçœ©æ™‚ä¸èƒ½å°„æ“Š)
    shootTimer -= dt;
    if(shootTimer <= 0 && p.stunTimer <= 0) {
        if(gameState.powerLevel === 1) {
            gameState.bullets.push({x: p.x, y: p.y-30, vx:0, vy:-800});
        } else {
            gameState.bullets.push({x: p.x, y: p.y-30, vx:0, vy:-800});
            gameState.bullets.push({x: p.x-15, y: p.y-20, vx:-200, vy:-750});
            gameState.bullets.push({x: p.x+15, y: p.y-20, vx:200, vy:-750});
        }
        shootTimer = 0.15;
    }

    // å°å…µç”Ÿæˆ
    if(gameState.phase === 1 && Math.random() < 0.05) {
        const isTurtle = Math.random() > 0.8;
        gameState.enemies.push({
            x: Math.random() * (canvas.width - 50) + 25,
            y: -50,
            type: isTurtle ? 'turtle' : 'minion',
            w: isTurtle ? 64 : 48, h: isTurtle ? 64 : 48,
            hp: isTurtle ? 6 : 2,
            vy: isTurtle ? 80 : 250,
            shootT: Math.random() * 1.5
        });
    }

    // æ•µäºº AI
    gameState.enemies.forEach(e => {
        e.shootT -= dt;
        if(e.shootT <= 0) {
            let dx = p.x - e.x;
            let dy = p.y - e.y;
            let len = Math.hypot(dx, dy) || 1;
            gameState.enemyBullets.push({x: e.x, y: e.y+20, vx: (dx/len)*300, vy: 300});
            e.shootT = e.type === 'turtle' ? 2.0 : 1.5; 
        }
    });

    // Boss AI
    if(gameState.boss) {
        const b = gameState.boss;
        if(b.y < 100) b.y += 50 * dt;
        b.x += 120 * dt * b.dir;
        if(b.x > canvas.width - 100 || b.x < 100) b.dir *= -1;

        b.shootTimer -= dt;
        if(b.shootTimer <= 0) {
            gameState.enemyBullets.push({x: b.x, y: b.y+80, vx:0, vy:450});
            gameState.enemyBullets.push({x: b.x-40, y: b.y+60, vx:-150, vy:400});
            gameState.enemyBullets.push({x: b.x+40, y: b.y+60, vx:150, vy:400});
            b.shootTimer = 0.8;
        }
        ui.bossFill.style.width = (b.hp / b.maxHp * 100) + "%";
        if(b.hp <= 0) winGame();
    }

    updateEntities(dt);
    checkCollisions();
}

function enterBossPhase() {
    gameState.phase = 2;
    gameState.enemies.forEach(e => createExplosion(e.x, e.y, '#f00'));
    gameState.enemies = [];
    gameState.enemyBullets = [];

    if(gameState.nukes < 3) {
        gameState.nukes++;
        updateNukeUI();
        showMsg("NUKE RELOADED!", "#0f0");
    }

    ui.phase.innerText = "WAVE 2: BOSS (60s)";
    ui.phase.style.color = "#f00";
    
    setTimeout(() => {
        gameState.boss = {
            x: canvas.width/2, y: -150,
            w: 200, h: 150,
            hp: 2500, maxHp: 2500,
            dir: 1, shootTimer: 0
        };
        ui.bossBar.style.display = 'block';
        showMsg("WARNING!!", "#f00");
    }, 1000);
}

function updateEntities(dt) {
    if(gameState.shake > 0) gameState.shake *= 0.9;
    if(gameState.shieldTime > 0) {
        gameState.shieldTime -= dt;
        ui.shieldTxt.style.display = 'block';
    } else { ui.shieldTxt.style.display = 'none'; }

    gameState.bullets.forEach(b => { b.x+=b.vx*dt; b.y+=b.vy*dt; });
    gameState.enemyBullets.forEach(b => { b.x+=b.vx*dt; b.y+=b.vy*dt; });
    gameState.enemies.forEach(e => e.y+=e.vy*dt);
    gameState.items.forEach(i => i.y+=150*dt);
    gameState.particles.forEach((p, i) => {
        p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
        if(p.life<=0) gameState.particles.splice(i,1);
    });

    gameState.bullets = gameState.bullets.filter(b => b.y > -50);
    gameState.enemyBullets = gameState.enemyBullets.filter(b => b.y < canvas.height+50);
    gameState.enemies = gameState.enemies.filter(e => e.y < canvas.height+50);
}

function checkCollisions() {
    // ç©å®¶å­å½ˆ
    gameState.bullets = gameState.bullets.filter(b => {
        let hit = false;
        for(let i=gameState.enemies.length-1; i>=0; i--) {
            let e = gameState.enemies[i];
            if(dist(b, e) < e.w/2 + 10) {
                e.hp--; hit = true;
                if(e.hp <= 0) {
                    createExplosion(e.x, e.y, '#f00');
                    if(Math.random()<0.25) spawnItem(e.x, e.y);
                    gameState.enemies.splice(i, 1);
                }
                break;
            }
        }
        if(!hit && gameState.boss && dist(b, gameState.boss) < 80) {
            gameState.boss.hp -= 10; hit = true;
        }
        return !hit;
    });

    // æšˆçœ©åˆ¤å®š
    gameState.enemies.forEach(e => {
        if(dist(gameState.player, e) < (e.w+gameState.player.w)/3) hitPlayer();
    });
    gameState.enemyBullets.forEach((b, i) => {
        if(dist(b, gameState.player) < 30) {
            hitPlayer();
            gameState.enemyBullets.splice(i, 1);
        }
    });

    // å¯¶ç‰©
    gameState.items = gameState.items.filter(i => {
        if(dist(i, gameState.player) < 40) {
            if(i.type === 'shield') gameState.shieldTime = 5;
            if(i.type === 'power') gameState.powerLevel = 2;
            showMsg(i.type === 'shield'?"SHIELD":"POWER UP", "#0f0");
            return false;
        }
        return true;
    });
}

function hitPlayer() {
    if(gameState.shieldTime > 0) return;
    // ä¿®æ­£ï¼šæšˆçœ©æ™‚é–“æ”¹ç‚º 0.2sï¼Œä¸¦ä¸”ç§»é™¤æ–‡å­—é¡¯ç¤º
    gameState.player.stunTimer = 0.2; 
    gameState.shake = 15;
}

function createExplosion(x, y, color) {
    for(let i=0; i<8; i++) {
        gameState.particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*300, vy: (Math.random()-0.5)*300,
            life: 0.5, color: color
        });
    }
}

function spawnItem(x, y) {
    gameState.items.push({ x:x, y:y, type: Math.random()>0.5?'shield':'power' });
}

function winGame() {
    gameState.boss = null;
    gameState.gameOver = true;
    ui.victory.style.display = 'flex';
}

function restartGame() {
    gameStarted = false; 
    startGame();
}

function showMsg(text, color) {
    ui.msg.innerText = text; ui.msg.style.color = color;
    ui.msg.style.display = 'block';
    setTimeout(() => ui.msg.style.display = 'none', 1500);
}

function dist(a, b) { return Math.hypot(a.x-b.x, a.y-b.y); }

// === è¼¸å…¥ ===
const input = { x: canvas.width/2, y: canvas.height-100, pressing: false };
function handleInput(x, y, pressing) { input.x = x; input.y = y; input.pressing = pressing; }
['touchstart', 'touchmove'].forEach(e => canvas.addEventListener(e, ev => {
    ev.preventDefault(); handleInput(ev.touches[0].clientX, ev.touches[0].clientY, true);
}, {passive: false}));
canvas.addEventListener('touchend', ev => { ev.preventDefault(); input.pressing = false; });
canvas.addEventListener('mousedown', ev => handleInput(ev.clientX, ev.clientY, true));
canvas.addEventListener('mousemove', ev => { if(input.pressing) handleInput(ev.clientX, ev.clientY, true); });
canvas.addEventListener('mouseup', () => input.pressing = false);

// === 6. ç¹ªåœ– ===
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    
    if(gameState.shake > 0.5) ctx.translate((Math.random()-0.5)*gameState.shake, (Math.random()-0.5)*gameState.shake);

    // èƒŒæ™¯
    if(assets.bg && assets.bg instanceof Image && assets.bg.width > 0) {
        ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);
    } else {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff';
        for(let i=0; i<20; i++) ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 2, 2);
    }

    // å¯¶ç‰©
    gameState.items.forEach(i => {
        let img = i.type === 'shield' ? assets.item_shield : assets.item_power;
        ctx.drawImage(img, i.x-20, i.y-20, 40, 40);
    });

    // æ•µäºº
    gameState.enemies.forEach(e => {
        let img = e.type === 'turtle' ? assets.enemy_turtle : assets.enemy_minion;
        ctx.drawImage(img, e.x-e.w/2, e.y-e.h/2, e.w, e.h);
    });

    // Boss
    if(gameState.boss) {
        let b = gameState.boss;
        ctx.drawImage(assets.boss, b.x-b.w/2, b.y-b.h/2, b.w, b.h);
    }

    // ç©å®¶
    let p = gameState.player;
    ctx.drawImage(assets.player, p.x-p.w/2, p.y-p.h/2, p.w, p.h);
    
    // æšˆçœ©ç‰¹æ•ˆ (åªè®Šè‰²ï¼Œä¸é¡¯ç¤ºæ–‡å­—)
    if(p.stunTimer > 0) {
        // ç•«ä¸€å€‹åŠé€æ˜é»ƒè‰²åœ“åœˆè¡¨ç¤ºæšˆçœ©
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "yellow";
        ctx.beginPath(); ctx.arc(p.x, p.y, 40, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    if(gameState.shieldTime > 0) {
        ctx.globalAlpha = 0.6; ctx.drawImage(assets.vfx_shield, p.x-48, p.y-48, 96, 96); ctx.globalAlpha = 1.0;
    }

    // å­å½ˆ
    gameState.bullets.forEach(b => ctx.drawImage(assets.bullet_player, b.x-8, b.y-16, 16, 32));
    gameState.enemyBullets.forEach(b => {
        if(assets.enemy_bullet && assets.enemy_bullet.width > 0) ctx.drawImage(assets.enemy_bullet, b.x-10, b.y-10, 20, 20);
        else { ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill(); }
    });

    // ç²’å­
    gameState.particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 5, 5); });

    ctx.restore();
}

function loop(timestamp) {
    if(!gameState.lastTime) gameState.lastTime = timestamp;
    const dt = (timestamp - gameState.lastTime) / 1000;
    gameState.lastTime = timestamp;
    update(dt);
    draw();
    if(gameStarted) requestAnimationFrame(loop);
}
</script>
</body>
</html>
