<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Pilot: Shield Evolution (Sprite Ver.)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; touch-action: none; }
        #game-container { position: relative; overflow: hidden; border: 2px solid #222; background: #000; }
        canvas { display: block; }
        
        /* UI å±¤ (ä¿æŒä¸è®Š) */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; }
        .hud-text { padding: 15px; font-weight: bold; text-shadow: 2px 2px #000; font-size: 18px; }
        
        /* å¸¥æ°£æ ¸å½ˆ UI */
        #nuke-container { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; pointer-events: auto; }
        .nuke-icon { 
            width: 45px; height: 45px; background: radial-gradient(circle, #fff, #f00); 
            border-radius: 50%; border: 3px solid #fff; cursor: pointer; 
            box-shadow: 0 0 15px #f00; display: flex; justify-content: center; align-items: center;
            font-size: 24px; font-weight: bold; color: black; animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
        
        #boss-hp-bar { display: none; position: absolute; top: 90px; left: 10%; width: 80%; height: 20px; background: #222; border: 3px solid #555; border-radius: 10px; overflow: hidden; box-shadow: 0 0 10px #f00; }
        #boss-hp-inner { width: 100%; height: 100%; background: linear-gradient(to right, #f00, #ff5e00); transition: width 0.1s; }
        
        /* è®€å–ç•«é¢ */
        #loading-screen { position: absolute; top:0; left:0; width:100%; height:100%; background:#000; color:#fff; display:flex; justify-content:center; align-items:center; font-size:24px; z-index: 100;}
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div class="hud-text">
                <span style="color:#0ff">TIME: <span id="timer">120</span>s</span><br>
                <span id="shield-status" style="color:#3498db; display:none;">ğŸ›¡ï¸ ç„¡æ•µä¸­!</span>
            </div>
            <div id="nuke-container"></div>
            <div id="boss-hp-bar"><div id="boss-hp-inner"></div></div>
            <div id="big-msg" style="position:absolute; top:40%; width:100%; text-align:center; font-size:40px; font-weight:bold; color:#0ff; text-shadow:0 0 20px #0ff; display:none; pointer-events:none;"></div>
        </div>
        <div id="loading-screen">LOADING ASSETS...</div>
    </div>

<script>
/** éŠæˆ²æ ¸å¿ƒå¸¸æ•¸ **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    timer: document.getElementById('timer'),
    msg: document.getElementById('big-msg'),
    nukeBox: document.getElementById('nuke-container'),
    bossBar: document.getElementById('boss-hp-bar'),
    bossFill: document.getElementById('boss-hp-inner'),
    shield: document.getElementById('shield-status'),
    loading: document.getElementById('loading-screen')
};

// === æ–°å¢ï¼šåœ–ç‰‡è³‡æºç®¡ç† ===
const assets = {};
const imageSources = {
    player: 'player.png',
    bulletPlayer: 'bullet_player.png',
    enemyMinion: 'enemy_minion.png',
    enemyTurtle: 'enemy_turtle.png',
    bulletEnemy: 'enemy_bullet.png',
    boss: 'boss.png',
    itemShield: 'item_shield.png',
    itemPower: 'item_power.png',
    bgSpace: 'bg_space.png',
    vfxShield: 'vfx_shield.png'
};
let assetsLoaded = 0;
const totalAssets = Object.keys(imageSources).length;

function loadAllAssets(callback) {
    for(let key in imageSources) {
        const img = new Image();
        img.onload = () => {
            assetsLoaded++;
            console.log(`Loaded: ${key} (${assetsLoaded}/${totalAssets})`);
            if(assetsLoaded === totalAssets) callback();
        };
        img.onerror = () => {
            console.error(`Failed to load image: ${imageSources[key]}. Make sure the file exists.`);
            alert(`ç¼ºå°‘æª”æ¡ˆ: ${imageSources[key]}\nè«‹ç¢ºä¿æ‰€æœ‰PNGåœ–æª”éƒ½å·²æ”¾åœ¨ç›®éŒ„ä¸­ã€‚`);
        };
        img.src = imageSources[key];
        assets[key] = img;
    }
}
// =======================

function resize() {
    const ratio = 450 / 800;
    let w = window.innerWidth, h = window.innerHeight;
    if (w / h > ratio) w = h * ratio; else h = w / ratio;
    canvas.width = 450; canvas.height = 800;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
    const container = document.getElementById('game-container');
    container.style.width = w + 'px'; container.style.height = h + 'px';
}
window.addEventListener('resize', resize);
resize();

// éŠæˆ²ç‹€æ…‹
let timeLeft = 120, isGameOver = false, isBossActive = false;
let isStunned = false, isInvincible = false;
let nukeCount = 3, firePower = 1, shake = 0, flash = 0, shock = 0;
let lastTime = performance.now();
let bgOffsetY = 0; // èƒŒæ™¯æ²å‹•ç”¨

const player = { x: 225, y: 700, tx: 225, ty: 700, speed: 10 };
const bullets = [], enemyBullets = [], enemies = [], items = [];
const boss = { x: 225, y: -200, hp: 2000, maxHp: 2000, dir: 1, shootCD: 0 };

// ç¹ªè£½æ ¸å½ˆ UI
function refreshNukes() {
    ui.nukeBox.innerHTML = '';
    for(let i=0; i<nukeCount; i++) {
        const div = document.createElement('div');
        div.className = 'nuke-icon';
        div.innerHTML = 'â˜¢';
        div.onclick = (e) => { e.stopPropagation(); useNuke(); };
        ui.nukeBox.appendChild(div);
    }
}
refreshNukes();

// æ“ä½œï¼šæŒ‡å“ªé£›å“ª
const handleMove = (ex, ey) => {
    if (isGameOver) return;
    const rect = canvas.getBoundingClientRect();
    player.tx = (ex - rect.left) * (450 / rect.width);
    player.ty = (ey - rect.top) * (800 / rect.height);
    // é™åˆ¶ä¸»è§’ä¸è¦é£›å‡ºè¢å¹•å¤ªé 
    player.tx = Math.max(30, Math.min(420, player.tx));
    player.ty = Math.max(30, Math.min(770, player.ty));
};
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('touchmove', e => {
    handleMove(e.touches[0].clientX, e.touches[0].clientY);
    e.preventDefault();
}, {passive: false});

function useNuke() {
    if (nukeCount <= 0 || isStunned || isGameOver) return;
    nukeCount--; refreshNukes();
    shake = 40; flash = 1.2; shock = 10;
    enemies.length = 0; enemyBullets.length = 0;
    if (isBossActive) boss.hp -= 400;
}

function triggerStun() {
    if (isInvincible || isStunned || isGameOver) return;
    isStunned = true; shake = 15; flash = 0.3;
    setTimeout(() => { isStunned = false; }, 1000);
}

// éŠæˆ²ä¸»è¿´åœˆ (ç¾åœ¨éœ€è¦ç­‰å¾…è³‡æºè¼‰å…¥å¾Œæ‰å•Ÿå‹•)
function loop(now) {
    if (isGameOver) return;
    let dt = (now - lastTime) / 1000;
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
}

function update(dt) {
    timeLeft -= dt;
    ui.timer.innerText = Math.max(0, Math.ceil(timeLeft));
    if (timeLeft <= 0) finish(false);
    if (!isBossActive && timeLeft <= 75) startBoss();

    // èƒŒæ™¯æ²å‹•
    bgOffsetY = (bgOffsetY + dt * 100) % 800;

    // é£›æ©Ÿå¹³æ»‘è·Ÿéš¨
    player.x += (player.tx - player.x) * 0.15;
    player.y += (player.ty - player.y) * 0.15;

    // è‡ªå‹•å°„æ“Š
    player.cd = (player.cd || 0) - dt;
    if (player.cd <= 0 && !isStunned) {
        bullets.push({ x: player.x, y: player.y - 30 });
        if (firePower >= 2) {
            bullets.push({ x: player.x - 25, y: player.y - 15 });
            bullets.push({ x: player.x + 25, y: player.y - 15 });
        }
        player.cd = 0.12;
    }

    // å­å½ˆç§»å‹•
    bullets.forEach((b, i) => { b.y -= 15; if (b.y < -50) bullets.splice(i, 1); });
    enemyBullets.forEach((b, i) => { 
        b.x += (b.vx || 0);
        b.y += (b.vy || 6); 
        if (b.y > 850 || b.y < -50 || b.x > 500 || b.x < -50) enemyBullets.splice(i, 1); 
    });

    // å°å…µèˆ‡çƒé¾œç”Ÿæˆ
    if (!isBossActive && Math.random() < 0.04) {
        let isTurtle = Math.random() < 0.25;
        enemies.push({ 
            x: Math.random() * 400 + 25, y: -50, 
            s: isTurtle ? 2.5 : 5, 
            type: isTurtle ? 'turtle' : 'minion',
            hp: isTurtle ? 6 : 1,
            angle: 0
        });
    }

    enemies.forEach((e, i) => {
        e.y += e.s;
        // ç°¡å–®çš„æ—‹è½‰æ•ˆæœ
        e.angle += dt * 2;
        
        if (e.type === 'minion' && Math.random() > 0.98) {
            let angle = Math.atan2(player.y - e.y, player.x - e.x);
            // å¢åŠ ä¸€é»éš¨æ©Ÿæ•£ä½ˆ
            angle += (Math.random()-0.5) * 0.2;
            enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(angle)*6, vy: Math.sin(angle)*6 });
        }
        
        if (e.y > 850) enemies.splice(i, 1);
        
        // ç¢°æ’æª¢æ¸¬ (æ•µäºº vs ç©å®¶)
        // ä½¿ç”¨è¼ƒå°çš„åˆ¤å®šç¯„åœè®“é–ƒé¿æ›´å®¹æ˜“
        if (Math.abs(e.x - player.x) < 30 && Math.abs(e.y - player.y) < 30) {
            if (!isInvincible) triggerStun();
            enemies.splice(i, 1);
        }

        bullets.forEach((b, bi) => {
            // ç¢°æ’æª¢æ¸¬ (å­å½ˆ vs æ•µäºº)
            let hitBox = e.type === 'turtle' ? 35 : 25;
            if (Math.abs(b.x - e.x) < hitBox && Math.abs(b.y - e.y) < hitBox) {
                e.hp--; bullets.splice(bi, 1);
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                    if (e.type === 'turtle') items.push({ x: e.x, y: e.y, type: 'shield' });
                    else if (Math.random() > 0.85) items.push({ x: e.x, y: e.y, type: 'power' });
                }
            }
        });
    });

    // é“å…·é‚è¼¯
    items.forEach((it, i) => {
        it.y += 3;
        it.angle = (it.angle || 0) + dt * 5; // é“å…·æ—‹è½‰
        if (it.y > 850) items.splice(i, 1);
        if (Math.abs(it.x - player.x) < 40 && Math.abs(it.y - player.y) < 40) {
            if (it.type === 'shield') activateShield();
            else firePower = 2;
            items.splice(i, 1);
        }
    });

    // BOSS
    if (isBossActive) {
        if (boss.y < 150) boss.y += 2;
        boss.x += boss.dir * 2.5;
        if (boss.x > 350 || boss.x < 100) boss.dir *= -1;
        
        if (Math.random() > 0.94) {
            // Boss ç™¼å°„æ‰‡å½¢å­å½ˆ
            for(let a=-1; a<=1; a++) {
                 enemyBullets.push({ x: boss.x + a*40, y: boss.y+60, vx: a*1.5, vy: 7 });
            }
        }
        bullets.forEach((b, bi) => {
            // Boss ç¢°æ’åˆ¤å®šå€ (è¼ƒå¤§)
            if (Math.abs(b.x - boss.x) < 90 && Math.abs(b.y - boss.y) < 70) {
                boss.hp -= (firePower*2); bullets.splice(bi, 1);
                ui.bossFill.style.width = Math.max(0, (boss.hp / boss.maxHp * 100)) + '%';
                if (boss.hp <= 0) finish(true);
            }
        });
    }

    enemyBullets.forEach((eb, i) => {
        // ç¢°æ’æª¢æ¸¬ (æ•µå½ˆ vs ç©å®¶)
        if (Math.abs(eb.x - player.x) < 20 && Math.abs(eb.y - player.y) < 20) {
            if (!isInvincible) triggerStun();
            enemyBullets.splice(i, 1);
        }
    });
}

function activateShield() {
    isInvincible = true;
    // ui.shield.style.display = 'inline'; // ä¸å†éœ€è¦æ–‡å­—æç¤º
    setTimeout(() => {
        isInvincible = false;
        // ui.shield.style.display = 'none';
    }, 6000);
}

// === é‡é ­æˆ²ï¼šå…¨æ–°çš„ç¹ªåœ–å‡½æ•¸ ===
function draw() {
    ctx.save();
    
    // 1. è¢å¹•éœ‡å‹•æ•ˆæœ
    if (shake > 0) {
        ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
        shake *= 0.9;
        if (shake < 0.5) shake = 0;
    }
    
    ctx.clearRect(0, 0, 450, 800);
    
    // 2. ç¹ªè£½èƒŒæ™¯ (ç„¡ç¸«æ²å‹•)
    // ç•«å…©å¼µåœ–å‰å¾Œæ‹¼æ¥å¯¦ç¾æ²å‹•
    ctx.drawImage(assets.bgSpace, 0, bgOffsetY - 800, 450, 800);
    ctx.drawImage(assets.bgSpace, 0, bgOffsetY, 450, 800);


    // 3. ç¹ªè£½æ ¸å½ˆè¡æ“Šæ³¢ç‰¹æ•ˆ
    if (shock > 0) {
        ctx.save();
        ctx.beginPath(); ctx.arc(225, 400, shock, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255,50,50,${1-shock/900})`; ctx.lineWidth = 30 * (1-shock/900); ctx.stroke();
        ctx.restore();
        shock += 35; if(shock > 900) shock = 0;
    }

    // 4. ç¹ªè£½ç©å®¶
    if (!isStunned || Math.floor(Date.now()/100)%2) {
        // ç¹ªè£½é£›æ©Ÿæœ¬é«” (64x64, ä¸­å¿ƒé»å°é½Š)
        ctx.drawImage(assets.player, player.x - 32, player.y - 32, 64, 64);
        
        // å¦‚æœç„¡æ•µï¼Œç¹ªè£½è­·ç›¾ç‰¹æ•ˆ (96x96)
        if (isInvincible) {
             ctx.save();
             ctx.globalAlpha = 0.8 + Math.sin(Date.now()/100)*0.2; // è®“è­·ç›¾é–ƒçˆ
             ctx.drawImage(assets.vfxShield, player.x - 48, player.y - 48, 96, 96);
             ctx.restore();
        }
    }

    // 5. ç¹ªè£½å­å½ˆ
    // ç©å®¶å­å½ˆ (16x32)
    bullets.forEach(b => {
        ctx.drawImage(assets.bulletPlayer, b.x - 8, b.y - 16, 16, 32);
    });
    // æ•µäººå­å½ˆ (24x24)
    enemyBullets.forEach(b => {
        ctx.drawImage(assets.bulletEnemy, b.x - 12, b.y - 12, 24, 24);
    });

    // 6. ç¹ªè£½æ•µäºº
    enemies.forEach(e => {
        ctx.save();
        ctx.translate(e.x, e.y);
        // è®“å°å…µç¨å¾®æ—‹è½‰å¢åŠ å‹•æ…‹æ„Ÿ
        if (e.type !== 'turtle') ctx.rotate(Math.sin(e.angle)*0.1); 
        
        if (e.type === 'turtle') {
            // çƒé¾œ (64x64)
            ctx.drawImage(assets.enemyTurtle, -32, -32, 64, 64);
        } else {
            // å°å…µ (48x48)
            ctx.drawImage(assets.enemyMinion, -24, -24, 48, 48);
        }
        ctx.restore();
    });

    // 7. ç¹ªè£½é“å…·
    items.forEach(it => {
        ctx.save();
        ctx.translate(it.x, it.y);
        ctx.rotate(it.angle); // é“å…·è‡ªè½‰
        let img = it.type === 'shield' ? assets.itemShield : assets.itemPower;
        // é“å…· (40x40)
        ctx.drawImage(img, -20, -20, 40, 40);
        ctx.restore();
    });

    // 8. ç¹ªè£½ BOSS
    if (isBossActive) {
        // Boss (200x150)
        ctx.drawImage(assets.boss, boss.x - 100, boss.y - 75, 200, 150);
    }
    
    ctx.restore();

    // 9. ç¹ªè£½å…¨è¢å¹•é–ƒå…‰ (æ ¸å½ˆæˆ–å—
