<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>天空小奇兵 - 史詩終章</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { box-shadow: 0 0 30px rgba(0, 200, 255, 0.5); border: 2px solid #333; }
    </style>
</head>
<body>

<script>
/**
 * 遊戲設定：自動適應尺寸
 */
const config = {
    type: Phaser.AUTO,
    width: 450,
    height: 800,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    physics: { default: 'arcade', arcade: { gravity: { y: 0 } } },
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);

let player, cursors, bullets, enemies, nukes = 3, score = 0;
let nukeIcons = [], scoreText, statusText, boss, bossHPBar, bossHPMax = 200;
let isBossActive = false, canControl = true;

function preload() {
    // 建立向量圖形資源，防止黑畫面
    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

    // 1. 玩家飛機
    graphics.fillStyle(0x00ccff, 1);
    graphics.fillTriangle(0, 32, 16, 0, 32, 32);
    graphics.generateTexture('ship', 32, 32);
    graphics.clear();

    // 2. 敵機
    graphics.fillStyle(0xff3300, 1);
    graphics.fillCircle(16, 16, 16);
    graphics.generateTexture('enemy', 32, 32);
    graphics.clear();

    // 3. 子彈
    graphics.fillStyle(0xffff00, 1);
    graphics.fillRect(0, 0, 4, 12);
    graphics.generateTexture('bullet', 4, 12);
    graphics.clear();

    // 4. 核彈圖標
    graphics.lineStyle(2, 0xff0000);
    graphics.strokeCircle(20, 20, 18);
    graphics.fillStyle(0xff0000, 1);
    graphics.fillCircle(20, 20, 10);
    graphics.generateTexture('nuke', 40, 40);
}

function create() {
    // 背景星空感
    this.stars = this.add.blitter(0, 0, 'bullet');
    for (let i = 0; i < 50; i++) {
        this.stars.create(Phaser.Math.Between(0, 450), Phaser.Math.Between(0, 800)).setAlpha(0.3);
    }

    // 玩家與群組
    player = this.physics.add.sprite(225, 700, 'ship');
    player.setCollideWorldBounds(true);
    bullets = this.physics.add.group();
    enemies = this.physics.add.group();

    // 控制系統
    cursors = this.input.keyboard.createCursorKeys();
    
    // UI 文字
    scoreText = this.add.text(20, 20, 'SCORE: 0', { fontSize: '24px', fontStyle: 'bold', fill: '#0ff' });
    statusText = this.add.text(225, 400, 'MISSION START', { fontSize: '40px', fontStyle: 'bold', fill: '#fff' }).setOrigin(0.5);
    this.tweens.add({ targets: statusText, alpha: 0, duration: 2000 });

    // 核彈按鈕 UI
    for (let i = 0; i < 3; i++) {
        let n = this.add.image(410 - (i * 50), 40, 'nuke').setInteractive().setAlpha(0.8);
        n.on('pointerdown', () => useNuke.call(this));
        nukeIcons.push(n);
    }

    // 自動射擊
    this.time.addEvent({
        delay: 150,
        callback: () => { if (this.input.activePointer.isDown && canControl) fireBullet.call(this); },
        loop: true
    });

    // 敵人生成
    this.spawnTimer = this.time.addEvent({
        delay: 800,
        callback: spawnEnemy,
        callbackScope: this,
        loop: true
    });

    // 碰撞偵測
    this.physics.add.overlap(bullets, enemies, (b, e) => {
        e.destroy(); b.destroy();
        score += 100;
        scoreText.setText('SCORE: ' + score);
        if (score >= 3000 && !isBossActive) triggerBoss.call(this);
    });

    this.physics.add.overlap(player, enemies, () => {
        this.cameras.main.shake(200, 0.02);
    });
}

function update() {
    if (!canControl) return;

    // 鍵盤移動
    const speed = 350;
    player.setVelocity(0);
    if (cursors.left.isDown) player.setVelocityX(-speed);
    else if (cursors.right.isDown) player.setVelocityX(speed);
    if (cursors.up.isDown) player.setVelocityY(-speed);
    else if (cursors.down.isDown) player.setVelocityY(speed);

    // 滑鼠/觸控移動
    if (this.input.activePointer.isDown) {
        this.physics.moveToObject(player, this.input.activePointer, speed);
    }
}

function fireBullet() {
    let b = bullets.create(player.x, player.y - 20, 'bullet');
    b.setVelocityY(-600);
}

function spawnEnemy() {
    if (isBossActive) return;
    let x = Phaser.Math.Between(50, 400);
    let e = enemies.create(x, -50, 'enemy');
    e.setVelocityY(Phaser.Math.Between(200, 400));
}

function useNuke() {
    if (nukes <= 0 || !canControl) return;
    nukes--;
    nukeIcons[nukes].setVisible(false);

    this.cameras.main.flash(500, 255, 255, 255);
    this.cameras.main.shake(500, 0.05);

    enemies.clear(true, true);
    if (isBossActive && boss) {
        boss.hp -= 50;
        updateBossHP();
    }
}

function triggerBoss() {
    isBossActive = true;
    this.spawnTimer.remove();
    
    // 補給最後一顆核彈
    if (nukes < 3) {
        nukeIcons[nukes].setVisible(true);
        nukes++;
    }

    statusText.setText('WARNING: BOSS APPEARING').setAlpha(1);
    this.cameras.main.shake(1000, 0.01);

    this.time.delayedCall(2000, () => {
        statusText.setAlpha(0);
        boss = this.physics.add.sprite(225, -150, 'enemy').setScale(5).setTint(0xff0000);
        boss.hp = bossHPMax;
        this.tweens.add({ targets: boss, y: 150, duration: 2000, ease: 'Back.easeOut' });

        bossHPBar = this.add.rectangle(225, 250, 300, 15, 0xff0000);
        this.physics.add.overlap(bullets, boss, (boss, bullet) => {
            bullet.destroy();
            boss.hp -= 1;
            updateBossHP.call(this);
        });
    });
}

function updateBossHP() {
    const width = Math.max(0, (boss.hp / bossHPMax) * 300);
    bossHPBar.width = width;

    if (boss.hp <= 0) {
        victoryEffect.call(this);
    }
}

function victoryEffect() {
    canControl = false;
    isBossActive = false;
    boss.setVelocity(0);
    player.setVelocity(0);

    // 史詩級震撼結束感
    this.time.addEvent({
        delay: 100,
        repeat: 10,
        callback: () => {
            this.cameras.main.flash(50, 255, 255, 255);
            this.cameras.main.shake(100, 0.03);
            let boom = this.add.circle(boss.x + Phaser.Math.Between(-100, 100), boss.y + Phaser.Math.Between(-100, 100), 50, 0xffffff);
            this.tweens.add({ targets: boom, scale: 2, alpha: 0, duration: 300 });
        }
    });

    this.time.delayedCall(1500, () => {
        boss.destroy();
        bossHPBar.destroy();
        this.cameras.main.flash(1000, 255, 255, 255);
        statusText.setText('MISSION COMPLETE').setAlpha(1).setScale(1.5).setTint(0x00ff00);
        this.add.text(225, 480, 'LEGENDARY PILOT', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
    });
}
</script>

</body>
</html>
