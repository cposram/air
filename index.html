<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Pilot: Nuke Evolution</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; touch-action: none; }
        #game-container { position: relative; overflow: hidden; border: 2px solid #222; background: #000; width: 100%; height: 100%; max-width: 480px; max-height: 850px; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI å±¤ */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; z-index: 10; }
        .hud-text { padding: 15px; font-weight: bold; text-shadow: 2px 2px #000; font-size: 18px; }
        
        /* === ä¿®æ”¹éƒ¨åˆ†ï¼šå¸¥æ°£ç«ç®­æ ¸å½ˆ UI === */
        #nuke-container { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; pointer-events: auto; }
        .nuke-btn { 
            width: 50px; height: 50px; 
            /* é€™è£¡è®€å–ä½ çš„ç«ç®­åœ–æ¨™ */
            background: url('rocket_icon.png') center/cover no-repeat;
            background-color: rgba(0,0,0,0.5);
            border-radius: 50%; border: 2px solid #fff; cursor: pointer; 
            box-shadow: 0 0 10px #f00, inset 0 0 10px #f00; 
            transition: transform 0.1s;
        }
        /* è‹¥åœ–ç‰‡è®€å–å¤±æ•—ï¼Œé¡¯ç¤º Emoji ç•¶å‚™æ¡ˆ */
        .nuke-btn.fallback::after { content: 'ğŸš€'; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; font-size: 24px; }
        .nuke-btn:active { transform: scale(0.9); }

        #boss-hp-bar { display: none; position: absolute; top: 90px; left: 10%; width: 80%; height: 20px; background: #222; border: 3px solid #555; border-radius: 10px; overflow: hidden; box-shadow: 0 0 10px #f00; }
        #boss-hp-inner { width: 100%; height: 100%; background: linear-gradient(to right, #f00, #ff5e00); transition: width 0.1s; }
        
        /* === æ–°å¢éƒ¨åˆ†ï¼šç‰¹æ•ˆå±¤ === */
        #vfx-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; pointer-events: none; z-index: 5;
            mix-blend-mode: screen; /* éæ¿¾é»‘è‰²èƒŒæ™¯ */
        }
        #vfx-layer img { width: 100%; height: 100%; object-fit: cover; }

        #flash-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 20;
            transition: opacity 0.1s;
        }

        #big-msg { position:absolute; top:40%; width:100%; text-align:center; font-size:40px; font-weight:bold; color:#0ff; text-shadow:0 0 20px #0ff; display:none; pointer-events:none; }

        /* è®€å–ç•«é¢ */
        #loading-screen { position: absolute; top:0; left:0; width:100%; height:100%; background:#000; color:#fff; display:flex; justify-content:center; align-items:center; font-size:24px; z-index: 100; flex-direction: column;}
        #loading-text { margin-top: 10px; font-size: 16px; color: #aaa; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="vfx-layer"><img id="nuke-gif" src="" alt=""></div>
        <div id="flash-layer"></div>

        <div id="ui">
            <div class="hud-text">
                <span style="color:#0ff">TIME: <span id="timer">120</span>s</span><br>
                <span id="shield-status" style="color:#3498db; display:none;">ğŸ›¡ï¸ ç„¡æ•µä¸­!</span>
            </div>
            <div id="nuke-container"></div>
            <div id="boss-hp-bar"><div id="boss-hp-inner"></div></div>
            <div id="big-msg"></div>
        </div>
        <div id="loading-screen">
            <div>LOADING... <span id="loading-percent">0%</span></div>
            <div id="loading-text">åˆå§‹åŒ–ç³»çµ±ä¸­...</div>
        </div>
    </div>

<script>
/** éŠæˆ²æ ¸å¿ƒå¸¸æ•¸ **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// è¨­å®š Canvas è§£æåº¦ä»¥ç¬¦åˆé¡¯ç¤ºå¤§å°
function resize() {
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;
}
window.addEventListener('resize', resize);
resize();

const ui = {
    timer: document.getElementById('timer'),
    msg: document.getElementById('big-msg'),
    nukeBox: document.getElementById('nuke-container'),
    bossBar: document.getElementById('boss-hp-bar'),
    bossFill: document.getElementById('boss-hp-inner'),
    shield: document.getElementById('shield-status'),
    loading: document.getElementById('loading-screen'),
    loadingPercent: document.getElementById('loading-percent'),
    loadingText: document.getElementById('loading-text'),
    vfx: document.getElementById('vfx-layer'),
    nukeGif: document.getElementById('nuke-gif'),
    flash: document.getElementById('flash-layer')
};

// === åœ–ç‰‡è³‡æºç®¡ç† ===
const assets = {};
const imageSources = {
    player: { src: 'player.png', color: '#00f', w: 64, h: 64 },
    bulletPlayer: { src: 'bullet_player.png', color: '#0ff', w: 16, h: 32 },
    enemyMinion: { src: 'enemy_minion.png', color: '#f00', w: 48, h: 48 },
    enemyTurtle: { src: 'enemy_turtle.png', color: '#0f0', w: 64, h: 64 },
    bulletEnemy: { src: 'enemy_bullet.png', color: '#f0f', w: 24, h: 24 },
    boss: { src: 'boss.png', color: '#a00', w: 200, h: 150 },
    itemShield: { src: 'item_shield.png', color: '#3498db', w: 40, h: 40 },
    bgSpace: { src: 'bg_space.png', color: '#111', w: 450, h: 800 },
    vfxShield: { src: 'vfx_shield.png', color: 'rgba(0,255,255,0.3)', w: 96, h: 96 },
    // é›–ç„¶ CSS æœ‰è¨­å®šï¼Œä½†é€™è£¡åŠ è¼‰æ˜¯ç‚ºäº†ç¢ºä¿æª”æ¡ˆå­˜åœ¨
    rocketIcon: { src: 'rocket_icon.png', color: '#fff', w: 64, h: 64 } 
};

let assetsLoaded = 0;
const totalAssets = Object.keys(imageSources).length;

function createPlaceholder(color, w, h) {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const x = c.getContext('2d');
    x.fillStyle = color;
    x.fillRect(0, 0, w, h);
    x.strokeStyle = '#fff'; x.lineWidth = 2;
    x.beginPath(); x.moveTo(0,0); x.lineTo(w,h); x.moveTo(w,0); x.lineTo(0,h); x.stroke();
    return c;
}

function loadAllAssets(callback) {
    console.log("Start loading assets...");
    let loaded = 0;
    
    // å®‰å…¨æ©Ÿåˆ¶ï¼šå¦‚æœåœ–ç‰‡è®€å–å¡ä½ï¼Œ3ç§’å¾Œå¼·åˆ¶é–‹å§‹
    const fallbackTimeout = setTimeout(() => {
        if(loaded < totalAssets) {
            console.warn("Loading timeout, forcing start.");
            callback();
        }
    }, 3000);

    for(let key in imageSources) {
        const data = imageSources[key];
        const img = new Image();
        img.src = data.src;
        
        img.onload = () => {
            assets[key] = img;
            checkDone();
        };
        
        img.onerror = () => {
            console.warn(`Failed to load ${data.src}, using placeholder.`);
            assets[key] = createPlaceholder(data.color, data.w, data.h);
            checkDone();
        };
    }

    function checkDone() {
        loaded++;
        const pct = Math.floor((loaded / totalAssets) * 100);
        ui.loadingPercent.innerText = pct + "%";
        if(loaded >= totalAssets) {
            clearTimeout(fallbackTimeout);
            setTimeout(() => {
                ui.loading.style.display = 'none';
                callback();
            }, 500);
        }
    }
}

// === éŠæˆ²é‚è¼¯ ===
const gameState = {
    player: null,
    bullets: [],
    enemies: [],
    enemyBullets: [],
    items: [],
    boss: null,
    score: 0,
    time: 120,
    nukes: 3,
    shake: 0,
    gameOver: false
};

const input = { x: 0, y: 0, pressing: false };

// è§¸æ§/æ»‘é¼ æ§åˆ¶
canvas.addEventListener('pointerdown', (e) => {
    input.pressing = true;
    updateInput(e);
});
canvas.addEventListener('pointermove', (e) => {
    if(input.pressing) updateInput(e);
});
canvas.addEventListener('pointerup', () => input.pressing = false);

function updateInput(e) {
    const rect = canvas.getBoundingClientRect();
    input.x = e.clientX - rect.left;
    input.y = e.clientY - rect.top;
}

// === è§’è‰²é¡åˆ¥ ===
class Player {
    constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height - 100;
        this.w = 64; this.h = 64;
        this.shootTimer = 0;
        this.shieldTime = 0;
    }
    update(dt) {
        if(input.pressing) {
            // å¹³æ»‘ç§»å‹•
            this.x += (input.x - this.x) * 0.2;
            this.y += (input.y - this.y) * 0.2;
        }
        
        // é™åˆ¶é‚Šç•Œ
        this.x = Math.max(this.w/2, Math.min(canvas.width - this.w/2, this.x));
        this.y = Math.max(this.h/2, Math.min(canvas.height - this.h/2, this.y));

        // å°„æ“Š
        this.shootTimer -= dt;
        if(this.shootTimer <= 0) {
            gameState.bullets.push({x: this.x - 8, y: this.y - 30, vx: 0, vy: -800, type:'normal'});
            gameState.bullets.push({x: this.x + 8, y: this.y - 30, vx: 0, vy: -800, type:'normal'});
            this.shootTimer = 0.15;
        }

        // è­·ç›¾
        if(this.shieldTime > 0) {
            this.shieldTime -= dt;
            ui.shield.style.display = 'block';
        } else {
            ui.shield.style.display = 'none';
        }
    }
    draw(ctx) {
        ctx.drawImage(assets.player, this.x - this.w/2, this.y - this.h/2, this.w, this.h);
        if(this.shieldTime > 0) {
            ctx.save();
            ctx.globalAlpha = 0.5 + Math.sin(Date.now()/100) * 0.2;
            ctx.drawImage(assets.vfxShield, this.x - 48, this.y - 48, 96, 96);
            ctx.restore();
        }
    }
}

class Enemy {
    constructor(type) {
        this.type = type;
        this.x = Math.random() * (canvas.width - 50) + 25;
        this.y = -50;
        this.hp = type === 'minion' ? 2 : 5;
        this.img = type === 'minion' ? assets.enemyMinion : assets.enemyTurtle;
        this.w = type === 'minion' ? 48 : 64;
        this.h = type === 'minion' ? 48 : 64;
        this.vy = type === 'minion' ? 200 : 100;
        this.shootTimer = Math.random() * 2;
    }
    update(dt) {
        this.y += this.vy * dt;
        if(this.type === 'turtle') {
            this.shootTimer -= dt;
            if(this.shootTimer <= 0) {
                gameState.enemyBullets.push({x: this.x, y: this.y + 20, vx: 0, vy: 300});
                this.shootTimer = 2;
            }
        }
    }
    draw(ctx) {
        ctx.drawImage(this.img, this.x - this.w/2, this.y - this.h/2, this.w, this.h);
    }
}

// === æ ¸å¿ƒåŠŸèƒ½ï¼šæ ¸å½ˆè§¸ç™¼ ===
function initNukeUI() {
    ui.nukeBox.innerHTML = '';
    for(let i=0; i<gameState.nukes; i++) {
        const btn = document.createElement('div');
        btn.className = 'nuke-btn';
        // æª¢æ¸¬æ˜¯å¦æˆåŠŸè®€å–åœ–ç‰‡ï¼Œè‹¥ç„¡å‰‡åŠ ä¸Š fallback class
        const imgTest = new Image();
        imgTest.src = 'rocket_icon.png';
        imgTest.onerror = () => btn.classList.add('fallback');

        btn.onclick = (e) => {
            e.stopPropagation(); // é˜²æ­¢è§¸ç™¼ç§»å‹•
            triggerNuke(btn);
        };
        ui.nukeBox.appendChild(btn);
    }
}

function triggerNuke(btn) {
    if(gameState.gameOver) return;
    
    // 1. ç§»é™¤ UI
    btn.remove();
    gameState.nukes--;

    // 2. å•Ÿå‹•éœ‡å‹•
    gameState.shake = 30;

    // 3. ç™½å…‰é–ƒçˆ
    ui.flash.style.opacity = 1;
    setTimeout(() => ui.flash.style.opacity = 0, 100);

    // 4. æ’­æ”¾ GIF (åŠ ä¸Šæ™‚é–“æˆ³å¼·åˆ¶é‡æ’­)
    ui.nukeGif.src = `nuke_explosion.gif?t=${Date.now()}`;
    ui.vfx.style.display = 'block';
    
    // 1.5ç§’å¾Œé—œé–‰ GIF
    setTimeout(() => {
        ui.vfx.style.display = 'none';
    }, 1500);

    // 5. éŠæˆ²é‚è¼¯ï¼šæ¸…å ´
    gameState.enemies = []; // åˆªé™¤æ‰€æœ‰å°å…µ
    gameState.enemyBullets = []; // åˆªé™¤æ‰€æœ‰å­å½ˆ
    
    // å¦‚æœæœ‰ Bossï¼Œæ‰£å¤§è¡€
    if(gameState.boss) {
        gameState.boss.hp -= 500;
        // ç°¡å–®çš„æ“Šé€€æ•ˆæœ
        gameState.boss.y -= 50;
    }
}

// === ä¸»å¾ªç’° ===
let lastTime = 0;
function loop(timestamp) {
    if(!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

function update(dt) {
    if(gameState.gameOver) return;

    // éœ‡å‹•è¡°æ¸›
    if(gameState.shake > 0) {
        gameState.shake *= 0.9;
        if(gameState.shake < 0.5) gameState.shake = 0;
    }

    // å€’æ•¸è¨ˆæ™‚
    gameState.time -= dt;
    ui.timer.innerText = Math.ceil(gameState.time);
    if(gameState.time <= 0 && !gameState.boss) {
        spawnBoss();
    }

    // ç©å®¶æ›´æ–°
    gameState.player.update(dt);

    // ç”Ÿæˆæ•µäºº
    if(Math.random() < 0.02 && !gameState.boss) {
        gameState.enemies.push(new Enemy(Math.random()>0.7 ? 'turtle' : 'minion'));
    }

    // æ›´æ–°é™£åˆ—ç‰©ä»¶
    gameState.bullets.forEach(b => b.y += b.vy * dt);
    gameState.enemyBullets.forEach(b => b.y += b.vy * dt);
    
    gameState.enemies.forEach((e, i) => {
        e.update(dt);
        if(e.y > canvas.height + 50) gameState.enemies.splice(i, 1);
        
        // å­å½ˆç¢°æ’
        gameState.bullets.forEach((b, bi) => {
            if(Math.abs(b.x - e.x) < e.w/2 && Math.abs(b.y - e.y) < e.h/2) {
                e.hp--;
                gameState.bullets.splice(bi, 1);
                if(e.hp <= 0) gameState.enemies.splice(i, 1);
            }
        });
    });

    gameState.bullets = gameState.bullets.filter(b => b.y > -50);
}

function draw() {
    // èƒŒæ™¯
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç¹ªè£½èƒŒæ™¯åœ–
    if(assets.bgSpace) ctx.drawImage(assets.bgSpace, 0, 0, canvas.width, canvas.height);

    ctx.save();
    // === éœ‡å‹•æ‡‰ç”¨ ===
    if(gameState.shake > 0) {
        const dx = (Math.random() - 0.5) * gameState.shake;
        const dy = (Math.random() - 0.5) * gameState.shake;
        ctx.translate(dx, dy);
    }

    // ç•«ç©å®¶
    gameState.player.draw(ctx);

    // ç•«æ•µäºº
    gameState.enemies.forEach(e => e.draw(ctx));

    // ç•«å­å½ˆ
    ctx.fillStyle = '#0ff';
    gameState.bullets.forEach(b => {
        ctx.fillRect(b.x-2, b.y, 4, 10);
    });

    ctx.fillStyle = '#f0f';
    gameState.enemyBullets.forEach(b => {
        ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI*2); ctx.fill();
    });

    ctx.restore();
}

function spawnBoss() {
    // é€™è£¡é ç•™ Boss ç”Ÿæˆé‚è¼¯
    ui.msg.innerText = "WARNING!!";
    ui.msg.style.display = 'block';
    setTimeout(() => ui.msg.style.display = 'none', 2000);
}

// å•Ÿå‹•
loadAllAssets(() => {
    gameState.player = new Player();
    initNukeUI();
    requestAnimationFrame(loop);
});

</script>
</body>
</html>
