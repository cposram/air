<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Pilot: Full Asset Restore</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 480px; background: #000; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI 層 */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; z-index: 10; }
        .hud-text { padding: 15px; font-weight: bold; text-shadow: 2px 2px #000; font-size: 18px; }
        
        /* 核彈按鈕 */
        #nuke-container { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; pointer-events: auto; }
        .nuke-btn { 
            width: 50px; height: 50px; 
            /* 預設背景圖 */
            background: rgba(255, 0, 0, 0.2) url('rocket_icon.png') center/cover no-repeat;
            border-radius: 50%; border: 2px solid #fff; cursor: pointer; 
            box-shadow: 0 0 10px #f00; 
        }
        .nuke-btn:active { transform: scale(0.9); background-color: #f00; }

        /* 特效層 */
        #vfx-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; mix-blend-mode: screen; pointer-events: none; z-index: 5; }
        #vfx-layer img { width: 100%; height: 100%; object-fit: cover; }
        #flash-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 20; transition: opacity 0.1s; }

        #debug-info { position: absolute; bottom: 10px; left: 10px; color: #555; font-size: 12px; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="vfx-layer"><img id="nuke-gif" src="" alt=""></div>
        <div id="flash-layer"></div>

        <div id="ui">
            <div class="hud-text">
                <span style="color:#0ff">TIME: <span id="timer">120</span>s</span>
            </div>
            <div id="nuke-container"></div>
            <div id="debug-info">Loading Assets...</div>
        </div>
    </div>

<script>
// === 1. 初始化 ===
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    timer: document.getElementById('timer'),
    nukeBox: document.getElementById('nuke-container'),
    vfx: document.getElementById('vfx-layer'),
    nukeGif: document.getElementById('nuke-gif'),
    flash: document.getElementById('flash-layer'),
    debug: document.getElementById('debug-info')
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// === 2. 完整圖片資源載入器 (根據你的截圖檔名) ===
const assets = {};
const imageSources = {
    // 檔名必須完全對應你截圖中的檔案
    player: 'player.png',
    bullet_player: 'bullet_player.png',
    
    enemy_minion: 'enemy_minion.png',
    enemy_turtle: 'enemy_turtle.png',
    enemy_bullet: 'enemy_bullet.png',
    
    boss: 'boss.png',
    
    bg: 'bg_space.png',
    rocket_icon: 'rocket_icon.png',
    
    // 特效與道具
    item_shield: 'item_shield.png',
    item_power: 'item_power.png',
    vfx_shield: 'vfx_shield.png'
};

// 產生替代用色塊 (如果圖片還沒載入完，先顯示這個)
function createPlaceholder(color) {
    const c = document.createElement('canvas');
    c.width = 32; c.height = 32;
    const x = c.getContext('2d');
    x.fillStyle = color; x.fillRect(0,0,32,32);
    return c;
}

// 預設先填入色塊，避免遊戲崩潰
assets.player = createPlaceholder('#00f');
assets.bullet_player = createPlaceholder('#0ff');
assets.enemy_minion = createPlaceholder('#f00');
assets.enemy_turtle = createPlaceholder('#0f0');
assets.enemy_bullet = createPlaceholder('#f0f');
assets.boss = createPlaceholder('#a00');
assets.bg = null; 

// 開始載入真實圖片
let loadedCount = 0;
const totalImages = Object.keys(imageSources).length;

for(let key in imageSources) {
    const img = new Image();
    img.src = imageSources[key];
    img.onload = () => {
        assets[key] = img; // 載入成功，替換掉色塊
        loadedCount++;
        ui.debug.innerText = `Assets: ${loadedCount}/${totalImages}`;
    };
    img.onerror = () => {
        console.warn(`Failed to load: ${imageSources[key]}`);
    };
}

// === 3. 手機觸控輸入優化 ===
const input = { x: canvas.width/2, y: canvas.height-100, pressing: false };

function handleInput(x, y, pressing) {
    input.x = x;
    input.y = y;
    input.pressing = pressing;
}

canvas.addEventListener('touchstart', e => {
    e.preventDefault(); 
    handleInput(e.touches[0].clientX, e.touches[0].clientY, true);
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault(); 
    handleInput(e.touches[0].clientX, e.touches[0].clientY, true);
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    input.pressing = false;
});

// 電腦測試用
canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY, true));
canvas.addEventListener('mousemove', e => { if(input.pressing) handleInput(e.clientX, e.clientY, true); });
canvas.addEventListener('mouseup', () => input.pressing = false);

// === 4. 遊戲邏輯 ===
const gameState = {
    player: { x: canvas.width/2, y: canvas.height-100, w: 64, h: 64 },
    bullets: [],
    enemies: [],
    enemyBullets: [], // 敵人的子彈
    nukes: 3,
    shake: 0,
    time: 120,
    lastTime: 0
};

// 射擊計時器
let shootTimer = 0;

function initNukeUI() {
    ui.nukeBox.innerHTML = '';
    for(let i=0; i<gameState.nukes; i++) {
        const btn = document.createElement('div');
        btn.className = 'nuke-btn';
        // 確保按鈕顯示正確圖片，若沒載入則用 CSS 定義
        if(assets.rocket_icon && assets.rocket_icon.width > 0) {
            btn.style.backgroundImage = `url('rocket_icon.png')`;
        }
        
        btn.addEventListener('touchstart', (e) => { e.stopPropagation(); triggerNuke(btn); });
        btn.addEventListener('mousedown', (e) => { e.stopPropagation(); triggerNuke(btn); });
        ui.nukeBox.appendChild(btn);
    }
}

function triggerNuke(btn) {
    if(gameState.nukes <= 0) return;
    gameState.nukes--;
    btn.style.display = 'none';

    gameState.shake = 30;
    ui.flash.style.opacity = 1;
    setTimeout(() => ui.flash.style.opacity = 0, 100);
    
    ui.nukeGif.src = `nuke_explosion.gif?t=${Date.now()}`;
    ui.vfx.style.display = 'block';
    setTimeout(() => ui.vfx.style.display = 'none', 1500);

    gameState.enemies = []; 
    gameState.enemyBullets = [];
}

// === 5. 更新與繪製 ===
function update(dt) {
    // 玩家移動
    if(input.pressing) {
        gameState.player.x += (input.x - gameState.player.x) * 0.2;
        gameState.player.y += (input.y - gameState.player.y) * 0.2;
    }

    // 震動衰減
    if(gameState.shake > 0) gameState.shake *= 0.9;

    // 玩家射擊 (每0.15秒一發)
    shootTimer -= dt;
    if(shootTimer <= 0) {
        gameState.bullets.push({ x: gameState.player.x, y: gameState.player.y - 30, vy: -800 });
        shootTimer = 0.15;
    }

    // 生成敵人 (隨機產生 minion 或 turtle)
    if(Math.random() < 0.03) {
        const type = Math.random() > 0.8 ? 'turtle' : 'minion';
        gameState.enemies.push({ 
            x: Math.random() * (canvas.width - 50) + 25, 
            y: -50, 
            type: type,
            vy: type === 'minion' ? 200 : 80,
            hp: type === 'minion' ? 2 : 5,
            w: type === 'minion' ? 48 : 64,
            h: type === 'minion' ? 48 : 64
        });
    }

    // 更新物件
    gameState.bullets.forEach(b => b.y += b.vy * dt);
    gameState.enemies.forEach(e => e.y += e.vy * dt);
    
    // 子彈碰撞判定
    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
        let e = gameState.enemies[i];
        
        // 移除超出畫面的敵人
        if(e.y > canvas.height + 50) {
            gameState.enemies.splice(i, 1);
            continue;
        }

        // 檢查被子彈打到
        for (let j = gameState.bullets.length - 1; j >= 0; j--) {
            let b = gameState.bullets[j];
            if(Math.abs(b.x - e.x) < e.w/2 && Math.abs(b.y - e.y) < e.h/2) {
                e.hp--;
                gameState.bullets.splice(j, 1); // 移除子彈
                if(e.hp <= 0) {
                    gameState.enemies.splice(i, 1); // 移除敵人
                    break; 
                }
            }
        }
    }
    
    // 清理超出畫面的子彈
    gameState.bullets = gameState.bullets.filter(b => b.y > -50);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    // 震動
    if(gameState.shake > 0.5) {
        ctx.translate((Math.random()-0.5)*gameState.shake, (Math.random()-0.5)*gameState.shake);
    }

    // 1. 畫背景
    if(assets.bg && assets.bg.width > 0) {
        ctx.drawImage(assets.bg, 0, 0, canvas.width, canvas.height);
    } else {
        ctx.fillStyle = '#111'; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // 2. 畫玩家
    let p = gameState.player;
    ctx.drawImage(assets.player, p.x - p.w/2, p.y - p.h/2, p.w, p.h);

    // 3. 畫敵人 (根據類型選擇圖片)
    gameState.enemies.forEach(e => {
        let img = (e.type === 'turtle') ? assets.enemy_turtle : assets.enemy_minion;
        ctx.drawImage(img, e.x - e.w/2, e.y - e.h/2, e.w, e.h);
    });

    // 4. 畫子彈
    gameState.bullets.forEach(b => {
        // 如果有子彈圖片就畫圖，沒有就畫線條
        if(assets.bullet_player && assets.bullet_player.width > 0) {
            ctx.drawImage(assets.bullet_player, b.x - 8, b.y - 16, 16, 32);
        } else {
            ctx.fillStyle = '#0ff'; ctx.fillRect(b.x - 2, b.y, 4, 15);
        }
    });

    ctx.restore();
}

function loop(timestamp) {
    if(!gameState.lastTime) gameState.lastTime = timestamp;
    const dt = (timestamp - gameState.lastTime) / 1000;
    gameState.lastTime = timestamp;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

// 啟動
initNukeUI();
requestAnimationFrame(loop);

</script>
</body>
</html>
