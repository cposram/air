<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Pilot: Shield Evolution</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; touch-action: none; }
        #game-container { position: relative; overflow: hidden; border: 2px solid #222; }
        canvas { background: #000; display: block; }
        
        /* UI Â±§ */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; }
        .hud-text { padding: 15px; font-weight: bold; text-shadow: 2px 2px #000; }
        
        /* Â∏•Ê∞£Ê†∏ÂΩà UI */
        #nuke-container { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; pointer-events: auto; }
        .nuke-icon { 
            width: 40px; height: 40px; background: radial-gradient(circle, #fff, #f00); 
            border-radius: 50%; border: 3px solid #fff; cursor: pointer; 
            box-shadow: 0 0 15px #f00; display: flex; justify-content: center; align-items: center;
            font-size: 20px; font-weight: bold; color: black; animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
        
        #boss-hp-bar { display: none; position: absolute; top: 90px; left: 10%; width: 80%; height: 15px; background: #333; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #boss-hp-inner { width: 100%; height: 100%; background: linear-gradient(to right, #0ff, #00f); transition: width 0.1s; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div class="hud-text">
                <span style="color:#0ff">TIME: <span id="timer">120</span>s</span><br>
                <span id="shield-status" style="color:#3498db; display:none;">üõ°Ô∏è ÁÑ°Êïµ‰∏≠!</span>
            </div>
            <div id="nuke-container"></div>
            <div id="boss-hp-bar"><div id="boss-hp-inner"></div></div>
            <div id="big-msg" style="position:absolute; top:40%; width:100%; text-align:center; font-size:40px; font-weight:bold; color:#0ff; text-shadow:0 0 15px #0ff; display:none;"></div>
        </div>
    </div>

<script>
/** ÈÅäÊà≤Ê†∏ÂøÉÂ∏∏Êï∏ **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    timer: document.getElementById('timer'),
    msg: document.getElementById('big-msg'),
    nukeBox: document.getElementById('nuke-container'),
    bossBar: document.getElementById('boss-hp-bar'),
    bossFill: document.getElementById('boss-hp-inner'),
    shield: document.getElementById('shield-status')
};

function resize() {
    const ratio = 450 / 800;
    let w = window.innerWidth, h = window.innerHeight;
    if (w / h > ratio) w = h * ratio; else h = w / ratio;
    canvas.width = 450; canvas.height = 800;
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
    const container = document.getElementById('game-container');
    container.style.width = w + 'px'; container.style.height = h + 'px';
}
window.addEventListener('resize', resize);
resize();

// ÈÅäÊà≤ÁãÄÊÖã
let timeLeft = 120, isGameOver = false, isBossActive = false;
let isStunned = false, isInvincible = false;
let nukeCount = 3, firePower = 1, shake = 0, flash = 0, shock = 0;
let lastTime = performance.now();

const player = { x: 225, y: 700, tx: 225, ty: 700, speed: 10 };
const bullets = [], enemyBullets = [], enemies = [], items = [];
const boss = { x: 225, y: -200, hp: 2000, maxHp: 2000, dir: 1, shootCD: 0 };

// Áπ™Ë£ΩÊ†∏ÂΩà UI
function refreshNukes() {
    ui.nukeBox.innerHTML = '';
    for(let i=0; i<nukeCount; i++) {
        const div = document.createElement('div');
        div.className = 'nuke-icon';
        div.innerHTML = '‚ò¢';
        div.onclick = (e) => { e.stopPropagation(); useNuke(); };
        ui.nukeBox.appendChild(div);
    }
}
refreshNukes();

// Êìç‰ΩúÔºöÊåáÂì™È£õÂì™
const handleMove = (ex, ey) => {
    const rect = canvas.getBoundingClientRect();
    player.tx = (ex - rect.left) * (450 / rect.width);
    player.ty = (ey - rect.top) * (800 / rect.height);
};
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('touchmove', e => {
    handleMove(e.touches[0].clientX, e.touches[0].clientY);
    e.preventDefault();
}, {passive: false});

function useNuke() {
    if (nukeCount <= 0 || isStunned || isGameOver) return;
    nukeCount--; refreshNukes();
    shake = 30; flash = 1.0; shock = 10;
    enemies.length = 0; enemyBullets.length = 0;
    if (isBossActive) boss.hp -= 350;
}

function triggerStun() {
    if (isInvincible || isStunned || isGameOver) return;
    isStunned = true; shake = 10;
    setTimeout(() => { isStunned = false; }, 1000);
}

function loop(now) {
    if (isGameOver) return;
    let dt = (now - lastTime) / 1000;
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
}

function update(dt) {
    timeLeft -= dt;
    ui.timer.innerText = Math.max(0, Math.ceil(timeLeft));
    if (timeLeft <= 0) finish(false);
    if (!isBossActive && timeLeft <= 75) startBoss(); // 45ÁßíÂæåÈÄ≤Áéã

    // È£õÊ©üÂπ≥ÊªëË∑üÈö®
    player.x += (player.tx - player.x) * 0.15;
    player.y += (player.ty - player.y) * 0.15;

    // Ëá™ÂãïÂ∞ÑÊìä
    player.cd = (player.cd || 0) - dt;
    if (player.cd <= 0 && !isStunned) {
        bullets.push({ x: player.x, y: player.y - 25 });
        if (firePower >= 2) {
            bullets.push({ x: player.x - 20, y: player.y - 10 });
            bullets.push({ x: player.x + 20, y: player.y - 10 });
        }
        player.cd = 0.12;
    }

    // Â≠êÂΩàÁßªÂãï
    bullets.forEach((b, i) => { b.y -= 12; if (b.y < -30) bullets.splice(i, 1); });
    enemyBullets.forEach((b, i) => { 
        b.x += (b.vx || 0);
        b.y += (b.vy || 5); 
        if (b.y > 830 || b.y < -30 || b.x > 480 || b.x < -30) enemyBullets.splice(i, 1); 
    });

    // Â∞èÂÖµËàáÁÉèÈæúÁîüÊàê
    if (Math.random() < 0.05) {
        let isTurtle = Math.random() < 0.2; // 20% Ê©üÁéáÂá∫ÁÉèÈæú
        enemies.push({ 
            x: Math.random() * 410 + 20, y: -50, 
            s: isTurtle ? 2 : 4, 
            type: isTurtle ? 'turtle' : 'minion',
            hp: isTurtle ? 5 : 1
        });
    }

    enemies.forEach((e, i) => {
        e.y += e.s;
        // ÊôÆÈÄöÂ∞èÂÖµÊúÉÊîªÊìä
        if (e.type === 'minion' && Math.random() > 0.985) {
            let angle = Math.atan2(player.y - e.y, player.x - e.x);
            enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5 });
        }
        
        if (e.y > 830) enemies.splice(i, 1);
        
        // Á¢∞ÊíûÊ™¢Ê∏¨
        if (Math.abs(e.x - player.x) < 35 && Math.abs(e.y - player.y) < 35) {
            if (!isInvincible) triggerStun();
            enemies.splice(i, 1);
        }

        bullets.forEach((b, bi) => {
            if (Math.abs(b.x - e.x) < 30 && Math.abs(b.y - e.y) < 30) {
                e.hp--; bullets.splice(bi, 1);
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                    // ÁÉèÈæúÂøÖÊéâÈò≤Ë≠∑ÁΩ©ÔºåÂ∞èÂÖµÊ©üÁéáÊéâÂº∑Âåñ
                    if (e.type === 'turtle') items.push({ x: e.x, y: e.y, type: 'shield' });
                    else if (Math.random() > 0.9) items.push({ x: e.x, y: e.y, type: 'power' });
                }
            }
        });
    });

    // ÈÅìÂÖ∑ÈÇèËºØ
    items.forEach((it, i) => {
        it.y += 2;
        if (Math.abs(it.x - player.x) < 40 && Math.abs(it.y - player.y) < 40) {
            if (it.type === 'shield') activateShield();
            else firePower = 2;
            items.splice(i, 1);
        }
    });

    // BOSS
    if (isBossActive) {
        if (boss.y < 160) boss.y += 2;
        boss.x += boss.dir * 3;
        if (boss.x > 360 || boss.x < 90) boss.dir *= -1;
        if (Math.random() > 0.95) {
            for(let a=0; a<3; a++) enemyBullets.push({ x: boss.x-50+a*50, y: boss.y+40, vy: 6 });
        }
        bullets.forEach((b, bi) => {
            if (Math.abs(b.x - boss.x) < 90 && Math.abs(b.y - boss.y) < 60) {
                boss.hp -= (firePower*2); bullets.splice(bi, 1);
                ui.bossFill.style.width = (boss.hp / boss.maxHp * 100) + '%';
                if (boss.hp <= 0) finish(true);
            }
        });
    }

    enemyBullets.forEach((eb, i) => {
        if (Math.abs(eb.x - player.x) < 25 && Math.abs(eb.y - player.y) < 25) {
            if (!isInvincible) triggerStun();
            enemyBullets.splice(i, 1);
        }
    });
}

function activateShield() {
    isInvincible = true;
    ui.shield.style.display = 'inline';
    setTimeout(() => {
        isInvincible = false;
        ui.shield.style.display = 'none';
    }, 6000); // ÁÑ°Êïµ 6 Áßí
}

function draw() {
    ctx.save();
    if (shake > 0) {
        ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
        shake *= 0.9;
    }
    ctx.clearRect(0, 0, 450, 800);
    
    // ËÉåÊôØ
    ctx.fillStyle = '#050515'; ctx.fillRect(0,0,450,800);
    ctx.fillStyle = '#112';
    for(let i=0; i<20; i++) ctx.fillRect(Math.random()*450, (Date.now()/5 + i*100)%800, 2, 2);

    if (shock > 0) {
        ctx.beginPath(); ctx.arc(225, 400, shock, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255,255,255,${1-shock/800})`; ctx.lineWidth = 20; ctx.stroke();
        shock += 30; if(shock > 800) shock = 0;
    }

    // Áé©ÂÆ∂
    if (!isStunned || Math.floor(Date.now()/100)%2) {
        if (isInvincible) {
            ctx.beginPath(); ctx.arc(player.x, player.y, 40, 0, Math.PI*2);
            ctx.strokeStyle = '#3498db'; ctx.lineWidth = 3; ctx.stroke();
            ctx.fillStyle = 'rgba(52, 152, 219, 0.2)'; ctx.fill();
        }
        ctx.fillStyle = '#fff'; ctx.fillRect(player.x-20, player.y-10, 40, 20);
        ctx.fillStyle = '#f00'; ctx.fillRect(player.x-25, player.y-15, 50, 4);
    }

    ctx.fillStyle = '#0ff'; bullets.forEach(b => ctx.fillRect(b.x-2, b.y, 4, 15));
    ctx.fillStyle = '#f0f'; enemyBullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill(); });

    // Êïµ‰∫∫
    enemies.forEach(e => {
        if (e.type === 'turtle') {
            ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(e.x, e.y, 20, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.stroke();
        } else {
            ctx.fillStyle = '#f44'; ctx.beginPath(); ctx.moveTo(e.x, e.y+15); ctx.lineTo(e.x-15, e.y-15); ctx.lineTo(e.x+15, e.y-15); ctx.fill();
        }
    });

    // ÈÅìÂÖ∑
    items.forEach(it => {
        ctx.fillStyle = it.type === 'shield' ? '#3498db' : '#f1c40f';
        ctx.beginPath(); ctx.arc(it.x, it.y, 15, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.fillText(it.type === 'shield' ? 'üõ°Ô∏è' : 'üî•', it.x-8, it.y+5);
    });

    if (isBossActive) {
        ctx.fillStyle = '#222'; ctx.fillRect(boss.x-80, boss.y-40, 160, 80);
        ctx.fillStyle = '#f00'; ctx.fillRect(boss.x-20, boss.y-10, 40, 40);
        ctx.strokeStyle = '#0ff'; ctx.strokeRect(boss.x-82, boss.y-42, 164, 84);
    }
    ctx.restore();

    if (flash > 0) {
        ctx.fillStyle = `rgba(255,255,255,${flash})`; ctx.fillRect(0,0,450,800);
        flash -= 0.05;
    }
}

function startBoss() {
    isBossActive = true; nukeCount = 3; refreshNukes();
    ui.bossBar.style.display = 'block';
    ui.msg.innerText = '‚ö†Ô∏è BOSS APPEARING ‚ö†Ô∏è'; ui.msg.style.display = 'block';
    setTimeout(() => ui.msg.style.display = 'none', 3000);
}

function finish(win) {
    isGameOver = true;
    ui.msg.innerText = win ? 'üèÜ MISSION COMPLETE' : '‚ùå MISSION FAILED';
    ui.msg.style.color = win ? '#0ff' : '#f00'; ui.msg.style.display = 'block';
    if (win) { shake = 80; flash = 1.0; }
    setTimeout(() => location.reload(), 5000);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
