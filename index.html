<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>天空小奇兵 Pro - 限時獵殺</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #game-container { width: 100%; height: 100%; }
    </style>
</head>
<body>
<div id="game-container"></div>

<script>
/** 遊戲主配置 - 支持自適應 **/
const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    scale: {
        mode: Phaser.Scale.RESIZE, // 自動調整大小
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    physics: { default: 'arcade', arcade: { gravity: { y: 0 } } },
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);

let player, bullets, enemyBullets, enemies, items, nukes = 3;
let fireLevel = 1, isBossActive = false, isStunned = false;
let nukeIcons = [], scoreText, timerText, bg, boss, bossHPBar, bossHPMax = 1000;
let gameTimer = 60, bossTimerEvent, score = 0;

function preload() {
    const g = this.make.graphics({ x: 0, y: 0, add: false });
    
    // 1. 精細化直升機 (多層次繪圖)
    g.fillStyle(0xffffff); g.fillRoundedRect(8, 12, 16, 16, 4); // 主機身
    g.fillStyle(0x3498db); g.fillEllipse(16, 15, 6, 4); // 駕駛艙
    g.fillStyle(0xff0000); g.fillRect(0, 18, 32, 2); // 螺旋槳
    g.generateTexture('hero', 32, 32); g.clear();

    // 2. 敵方攔截機
    g.fillStyle(0xe74c3c); g.fillTriangle(0, 0, 32, 16, 0, 32);
    g.generateTexture('enemy', 32, 32); g.clear();

    // 3. 超級飛彈圖標 (核彈)
    g.lineStyle(2, 0xf1c40f); g.strokeCircle(20, 20, 18);
    g.fillStyle(0xf1c40f); g.fillTriangle(10, 30, 20, 10, 30, 30);
    g.generateTexture('nuke', 40, 40); g.clear();

    // 4. 粒子與子彈
    g.fillStyle(0x00ffff); g.fillRect(0, 0, 4, 12); g.generateTexture('bullet', 4, 12); g.clear();
}

function create() {
    const { width, height } = this.scale;

    // 峽谷背景 - 使用滾動紋理模擬
    bg = this.add.grid(width/2, height/2, width * 2, height * 2, 40, 40, 0x1a1a2e, 0.5, 0x16213e);
    
    // 玩家
    player = this.physics.add.sprite(width / 2, height - 100, 'hero').setScale(1.5);
    player.setCollideWorldBounds(true);
    
    // 群組
    bullets = this.physics.add.group();
    enemyBullets = this.physics.add.group();
    enemies = this.physics.add.group();
    items = this.physics.add.group();

    // UI 設計
    scoreText = this.add.text(20, 20, 'SCORE: 0', { fontSize: '24px', fontStyle: 'bold', fill: '#0ff' }).setScrollFactor(0);
    timerText = this.add.text(width / 2, 50, '', { fontSize: '40px', fontStyle: 'bold', fill: '#ff4757' }).setOrigin(0.5).setScrollFactor(0).setVisible(false);

    // 核彈 UI
    this.refreshNukeUI = () => {
        nukeIcons.forEach(i => i.destroy());
        nukeIcons = [];
        for (let i = 0; i < nukes; i++) {
            let n = this.add.image(width - 40 - (i * 50), 40, 'nuke').setInteractive().setScale(0.8);
            n.on('pointerdown', () => useNuke.call(this));
            nukeIcons.push(n);
        }
    };
    this.refreshNukeUI();

    // 自動發射
    this.time.addEvent({ delay: 150, callback: () => { if (!isStunned) fireBullet.call(this); }, loop: true });

    // 敵人生成
    this.spawnEvent = this.time.addEvent({ delay: 800, callback: spawnEnemy, callbackScope: this, loop: true });

    // 碰撞偵測
    this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
    this.physics.add.overlap(enemyBullets, player, hitPlayer, null, this);
    this.physics.add.overlap(player, enemies, hitPlayer, null, this);

    // 監聽視窗縮放
    this.scale.on('resize', (gameSize) => {
        const { width, height } = gameSize;
        bg.setPosition(width / 2, height / 2);
        scoreText.setPosition(20, 20);
        timerText.setPosition(width / 2, 50);
        this.refreshNukeUI();
    });
}

function update() {
    bg.y += 2; if (bg.y > 40) bg.y = 0; // 無盡滾動
    
    if (isStunned) {
        player.angle += 20; // 暈眩旋轉效果
        return;
    } else {
        player.angle = 0;
    }

    const speed = 400;
    const pointer = this.input.activePointer;
    
    // 鍵盤移動
    const cursors = this.input.keyboard.createCursorKeys();
    player.setVelocity(0);
    if (cursors.left.isDown) player.setVelocityX(-speed);
    else if (cursors.right.isDown) player.setVelocityX(speed);
    if (cursors.up.isDown) player.setVelocityY(-speed);
    else if (cursors.down.isDown) player.setVelocityY(speed);

    // 手機觸控/滑鼠跟隨
    if (pointer.isDown) {
        this.physics.moveToObject(player, pointer, speed);
    }
}

function fireBullet() {
    let b = bullets.create(player.x, player.y - 30, 'bullet').setTint(0x00ffff);
    b.setVelocityY(-700);
}

function spawnEnemy() {
    if (isBossActive) return;
    let e = enemies.create(Phaser.Math.Between(50, this.scale.width - 50), -50, 'enemy');
    e.setVelocityY(Phaser.Math.Between(200, 400));
    e.setAngle(90);
    
    // 敵機偶爾開火
    if (Phaser.Math.Between(0, 10) > 7) {
        let eb = enemyBullets.create(e.x, e.y, 'bullet').setTint(0xff4757);
        this.physics.moveToObject(eb, player, 300);
    }
}

function hitEnemy(bullet, enemy) {
    bullet.destroy();
    enemy.destroy();
    score += 100;
    scoreText.setText('SCORE: ' + score);
    if (score >= 3000 && !isBossActive) startBossPhase.call(this);
}

/** 暈眩機制：被打到不會死，只會轉圈圈 **/
function hitPlayer(p, enemyOrBullet) {
    if (isStunned) return;
    enemyOrBullet.destroy();
    
    isStunned = true;
    this.cameras.main.shake(300, 0.02);
    player.setTint(0xff0000);

    this.time.delayedCall(1200, () => {
        isStunned = false;
        player.clearTint();
    });
}

function useNuke() {
    if (nukes <= 0 || isStunned) return;
    nukes--;
    this.refreshNukeUI();
    
    this.cameras.main.flash(500, 255, 255, 255);
    enemies.clear(true, true);
    enemyBullets.clear(true, true);
    if (isBossActive && boss) {
        boss.hp -= 200;
        updateBossHP();
    }
}

/** Boss 戰前置：補滿超級飛彈 **/
function startBossPhase() {
    isBossActive = true;
    this.spawnEvent.remove();
    
    // 補滿三顆核彈
    nukes = 3;
    this.refreshNukeUI();

    const warn = this.add.text(this.scale.width/2, this.scale.height/2, 'BOSS WARNING', { fontSize: '50px', fontStyle: 'bold', fill: '#f00' }).setOrigin(0.5);
    this.tweens.add({ targets: warn, alpha: 0, duration: 500, yoyo: true, repeat: 3, onComplete: () => {
        warn.destroy();
        spawnBoss.call(this);
    }});
}

function spawnBoss() {
    boss = this.physics.add.sprite(this.scale.width/2, -150, 'enemy').setScale(5).setTint(0xff4757);
    boss.hp = bossHPMax;
    boss.setAngle(90);
    this.tweens.add({ targets: boss, y: 150, duration: 2000, ease: 'Back.easeOut' });

    // Boss 血條
    this.hpBg = this.add.rectangle(this.scale.width/2, 100, 300, 10, 0x333333).setScrollFactor(0);
    bossHPBar = this.add.rectangle(this.scale.width/2, 100, 300, 10, 0xff0000).setScrollFactor(0);

    // 啟動限時器
    timerText.setVisible(true).setText(gameTimer);
    bossTimerEvent = this.time.addEvent({
        delay: 1000,
        callback: () => {
            gameTimer--;
            timerText.setText(gameTimer);
            if (gameTimer <= 0) finalizeGame.call(this, false);
        },
        loop: true
    });

    // Boss 瘋狂彈幕
    this.time.addEvent({
        delay: 1500,
        callback: () => {
            if (!boss.active) return;
            for(let i=0; i<8; i++) {
                let eb = enemyBullets.create(boss.x, boss.y, 'bullet').setTint(0xffa502);
                this.physics.velocityFromAngle(i * 45, 250, eb.body.velocity);
            }
        },
        loop: true
    });

    this.physics.add.overlap(bullets, boss, (b, bull) => {
        bull.destroy();
        boss.hp -= 2;
        updateBossHP();
    });
}

function updateBossHP() {
    if (!bossHPBar) return;
    const w = Math.max(0, (boss.hp / bossHPMax) * 300);
    bossHPBar.width = w;
    if (boss.hp <= 0) finalizeGame.call(this, true);
}

function finalizeGame(isWin) {
    if (bossTimerEvent) bossTimerEvent.remove();
    isBossActive = false;
    
    const result = isWin ? 'MISSION COMPLETE' : 'MISSION FAILED';
    const color = isWin ? '#2ecc71' : '#e74c3c';
    
    if (isWin) {
        boss.destroy();
        this.cameras.main.flash(1000, 255, 255, 255);
    }

    this.add.text(this.scale.width/2, this.scale.height/2, result, { 
        fontSize: '50px', fontStyle: 'bold', fill: color, stroke: '#000', strokeThickness: 8 
    }).setOrigin(0.5);

    this.time.delayedCall(3000, () => location.reload());
}
</script>
</body>
</html>